#!/bin/sh

VERSION="sw-mgr v0.45.0 - 20080609"
help() {
    cat <<EOD
Usage: `basename $0` [OPTION]
   OPTIONS
   -------
   --force|-f                         Force installation/removal
   --override-lock                    Override the locks in the caches
   --help|-h                          Display this help
   --debug                            Enable debug output
   --install|-i <release number>      Install the selected release
   --validate|-V <release number>     Install and test the selected release
   --update|-u                        Update the selected release
   --test <release number>            Test the selected release
   --remove|-r  <release number>      Remove the selected release
   --manage|-M  <release number>      Manage the selected release
   --kit-cache|-k <URL>               Use URL as cache to download the kit
   --dbrelease <dbrel version>        Install the <dbrel version> DB release
   --cleanup|-C                       Delete the destination dirs
   --check                            Executes the pre-install checks
   --add-tags                         Add one or more tags
   --dump-tags <file>                 Dump the tags in <file>
   --force-tags                       Force the publishing of the tags
   --extra-tag                        Use an extra, unique tag suffix
   --extra-pkg <pkg>                  Install the extra package <pkg>
   --disk-free <PHYS>:<LOG>           Requires at least <PHYS> bytes free
                                      in the physical install area and
                                      <LOG> bytes free in the logical
                                      install area (default: $MINDF)
   --min-install-size <size in bytes> minimum installation size in bytes
                                      (default: $MININSTALLSIZE)
   --host|-H <hostname>               Use <hostname> for tagging activities
   --reinstall                        Reinstall the selected release
   --reinstall-clean                  Clean the old install when reinstalling
   --no-tag                           Don't manage tags after testing
   --no-opt                           Don't use the optimization tag
   --pacball                          Use pacballs instead of snapshots
   --remove-tags                      Remove one or more tags
   --remove-snap|-R <release number>  Remove the snapshot for <release number>
   --replicate                        Replicate the installation files
   --require-shfs|-S                  Require that the install area is a shared fs
   --require-prj <project name>       Require <project name> to be installed
   --dest <path>                      Install the release in <path>
   --logical|-l <path>                Install or manage the main logical release from <path>
   --package <package name>           Use the package <package name>
   --pacman-ver|-m <version>          Use pacman <version>
   --pretend-platform <platform>      Force pacman to assume using <platform>
   --no-cache|-n                      Don't create a snapshot for this release
   --no-version                       Don't use the version when getting packages
   --use-grid                         Use the Grid SEs to hold the snapshots
   --release-only|-o                  Pack only the release, no compiler or KV
   --physical <path>|-p               Install or manage the main physical release from <path>
   --project <project name>|-P        Use project <project name>
   --project-type <type>|-T           Use project type <type>
                                      <type> = release   -> production releases
                                      <type> = bugfix    -> bugfix nightlies
                                      <type> = dev       -> dev nightlies
                                      <type> = p1nightly -> point1 nightlies
                                      <type> = patch     -> production patches
                                      <type> = p1patch   -> point1 patches
                                      <type> = eventview -> PAT/EventView patches
   --project-opt <option>|-O          Use optimization <option>
                                      <option> = opt -> optimized mode
                                      <option> = dbg -> debug mode
   --snap|-s <release number>         Create a snapshot for the selected release
   --snapname <snapshot name>         Use <snapshot name> for the snapshot
                                      file name
   --create-dvd|-c                    Create a DVD image with the local releases
   --write-dvd|-w <image name>        Create the DVD image <image name>
   --dir|-d <installation directory>  Use <installation directory>
                                      for the installation
   --release-ver|-v <release version> Set the release version (default: ${RELVER})
   --target|-t <arch>                 Use <arch> architecture for installing
   --tthreads <n>                     Use <n> test threads (default: ${TESTTHR})
   --temp-cache                       Use a temporary cache to install
   --vo <VO name>                     VO name (default: ${TAGVO})
   --tags <TAG1,TAG2,TAG3,...>        Tag names, separated by commas
   --query|-q                         Query the available (local) releases
   --quiet|-Q                         Disable verbose output
   --xml|-x <file name>               Generate an XML report of the installation
   --kvpost                           Post the test results to the GKV portal
   --kv-cache <cache>                 Use the <cache> KitValidation cache
   --kv-conf <URL>                    Use <URL> to get the KV configuration
   --kv-disable <testlist>            Disable the selected KV tests
   --kv-enable <testlist>             Enable the selected KV tests
   --kvpost-tag <tag>                 Use <tag> when posting to GKV
   --setup-latest <path>              Setup the latest release from <path>
                                      at the beginning of the task
   --setenv <v1=val,v2=val,...>       Set the value of v1=val, v2=val, ...
                                      in the installation setup scripts
   --validation-exe <file>            Use <file> to validate the installation

$VERSION
Alessandro De Salvo <Alessandro.DeSalvo@roma1.infn.it>
EOD
}


msgOut() {
   MSGTYPE="$1"
   MSGTEXT="$2"
   [ "$QUIET" == "" ] && echo "SWMGR> ${MSGTYPE}: ${MSGTEXT}"
   [ "$XMLFILE" != "" ] && xml add "    <swmgr type=\"$MSGTYPE\">${MSGTEXT}</swmgr>"
   return 0
}


xml() {
   XMLCMD="${1}"
   XMLSTR="${2}"
   if [ "$XMLFILE" != "" ] ; then
       if [ "$XMLCMD" == "add" ] ; then
           echo $XMLSTR >> $XMLFILE
       fi
       if [ "$XMLCMD" == "open" ] ; then
           echo "<?xml version="1.0" encoding="UTF-8"?>" > $XMLFILE
           echo "<install>" >> $XMLFILE
       fi
       if [ "$XMLCMD" == "close" ] ; then
           echo "</install>" >> $XMLFILE
       fi
   fi
}

getFSType() {
    MOUNTPOINT="${1}"
    MOUNTPOINTFS="`df -T -P ${MOUNTPOINT} | tail -n 1 | awk '{print $2}'`"
    echo $MOUNTPOINTFS
    return 0
}

getDiskFree() {
    MOUNTPOINT="${1}"
    MOUNTPOINTFS="`getFSType ${MOUNTPOINT}`"
    if [ "$MOUNTPOINTFS" == "afs" ] ; then
        MOUNTPOINTDF="`fs listquota ${MOUNTPOINT} | tail -n 1 | awk '{print $2-$3}'`"
    else
        MOUNTPOINTDF="`df -k -P ${MOUNTPOINT} | tail -n 1 | awk '{print $4}'`"
    fi
    [ "$MOUNTPOINTDF" == "" ] && MOUNTPOINTDF=0
    echo $MOUNTPOINTDF
    return 0
}

isSharedFS() {
    MOUNTPOINT="${1}"
    FSTYPE="`getFSType ${MOUNTPOINT}`"
    [ "$FSTYPE" == "afs" -o "$FSTYPE" == "nfs" -o "$FSTYPE" == "nfs4" -o "$FSTYPE" == "gpfs" -o "$FSTYPE" == "panfs" -o "$FSTYPE" == "lustre" -o "$FSTYPE" == "none" -o "$FSTYPE" == "-" ] && echo "yes" || echo "no"
}

showSiteInfo() {
    msgOut INFO "======================="
    msgOut INFO "Resource info"
    msgOut INFO "Timestamp:  `date`"
    msgOut INFO "Running as: `whoami`"
    msgOut INFO "            `id`"
    msgOut INFO "Running on: `uname -a`"
    [ "`which lsb_release 2> /dev/null`" != "" ] && msgOut INFO "`lsb_release -d`"
    msgOut INFO "======================="
}

checkSite() {
    msgOut INFO "Site checks started on `date`"
    let checkrc=0
    RELSHAREDFS="`isSharedFS $RELLOC`"
    RELDF="`getDiskFree ${RELLOC}`"
    if [ "$RELDF" == "" -o $RELDF -lt $MINRELDF ] ; then
        msgOut ERROR "You don't have enough space in $RELLOC (actual=$RELDF, min=$MINRELDF)"
        let checkrc=100
    fi
    if [ "$RELSHAREDFS" == "no" -a "$REQSHAREDFS" == "yes" ] ; then
        msgOut ERROR "The directory $RELLOC is not in a shared filesystem"
        msgOut INFO "`df -T -P ${RELLOC} | tail -n 1`"
        let checkrc=110
    fi
    if [ "$PRJTYPE" != "patch" -a "$PRJTYPE" != "p1patch" -a "$PRJTYPE" != "eventview" ] ; then
        SWSHAREDFS="`isSharedFS $SWLOC`"
        SWDF="`getDiskFree ${SWLOC}`"
        if [ "$SWDF" == "" -o $SWDF -lt $MINSWDF ] ; then
            msgOut ERROR "You don't have enough space in $SWLOC (actual=$SWDF, min=$MINSWDF)"
            let checkrc=100
        fi
        if [ "$SWSHAREDFS" == "no" -a "$REQSHAREDFS" == "yes" ] ; then
            msgOut ERROR "The directory $SWLOC is not in a shared filesystem"
            msgOut INFO "`df -T -P ${SWLOC} | tail -n 1`"
            let checkrc=110
        fi
    fi
    TDSHAREDFS="`isSharedFS $TOPDIR`"
    TDDF="`getDiskFree ${TOPDIR}`"
    if [ "$TDDF" == "" -o $TDDF -lt $MINTDDF ] ; then
        msgOut ERROR "You don't have enough space in $TOPDIR (actual=$TDDF, min=$MINTDDF)"
        TOPDIR=/tmp/tmp.atlas.install.$$
        TDDF="`getDiskFree /tmp`"
        SNAPDIR="${TOPDIR}/`basename ${SNAPDIR}`"
        msgOut INFO  "Trying to use ${TOPDIR}..."
        if [ "$TDDF" == "" -o $TDDF -lt $MINTDDF ] ; then
            msgOut ERROR "You don't have enough space in $TOPDIR (actual=$TDDF, min=$MINTDDF)"
            if [ "$VO_ATLAS_SW_DIR" != "" ] ; then
                TOPDIR=$VO_ATLAS_SW_DIR/tmp.atlas.install.$$
                TDDF="`getDiskFree ${VO_ATLAS_SW_DIR}`"
                SNAPDIR="${TOPDIR}/`basename ${SNAPDIR}`"
                msgOut INFO  "Trying to use ${TOPDIR}..."
                if [ "$TDDF" == "" -o $TDDF -lt $MINTDDF ] ; then
                    msgOut ERROR "You don't have enough space in $TOPDIR (actual=$TDDF, min=$MINTDDF)"
                    let checkrc=100
                else
                    msgOut INFO  "${TOPDIR} disk free OK"
                fi
            else
                msgOut ERROR "You don't seem to have VO_ATLAS_SW_DIR set. Giving up."
                let checkrc=100
            fi
        else
            msgOut INFO  "${TOPDIR} disk free OK"
        fi
    fi
    if [ ! -d ${TOPDIR} -a $checkrc -eq 0 ] ; then
        mkdir -p ${TOPDIR}
        if [ $? -eq 0 ] ; then
            msgOut INFO  "Using ${TOPDIR} as temporary storage"
        else
            let checkrc=101
            msgOut ERROR "Cannot create the directory ${TOPDIR}"
        fi
    fi

    if [ $checkrc -eq 0 ] ; then
        msgOut INFO "Physical Area location:            $RELLOC"
        msgOut INFO "Physical Area details:             `\ls -ld $RELLOC`"
        msgOut INFO "Logical Area location:             $SWLOC"
        msgOut INFO "Temporary Area location:           $TOPDIR"
        msgOut INFO "Available space in Physical Area:  $RELDF bytes"
        msgOut INFO "Available space in Logical Area:   $SWDF bytes"
        msgOut INFO "Available space in Temporary Area: $TDDF bytes"
        msgOut INFO "System pre-checks OK"
    else
        msgOut INFO "System pre-checks FAILED"
    fi

    return $checkrc
}


getCloseReplica() {
    SOURCE="${1}"
    LCG_LR="`which lcg-lr 2>/dev/null`"
    if [ "$LCG_LR" != "" ] ; then
        $LCG_LR --vo $TAGVO ${SOURCE} 2>/dev/null | grep ${CLOSESE} | tail -n 1
    fi
}


getGridFile() {
    DEFSOURCE="lfn:${1}"
    SOURCE="${DEFSOURCE}"
    REPDEST="install/lcg/`basename ${1}`"
    DEST="file:${2}"
    LCG_CP="`which lcg-cp 2>/dev/null`"
    LCG_LR="`which lcg-lr 2>/dev/null`"
    LCG_LG="`which lcg-lg 2>/dev/null`"
    LCG_REP="`which lcg-rep 2>/dev/null`"
    GUID=""
    let getrc=0
    if [ "$LCG_LG" != "" ] ; then
        GUID="`$LCG_LG --vo $TAGVO ${SOURCE} 2>/dev/null`"
        if [ "$GUID" == "" ] ; then
            msgOut INFO "${SOURCE} not found in the Grid"
            let getrc=80
        else
            msgOut INFO "${SOURCE} OK"
            if [ "$CLOSESE" != "" ] ; then
                if [ "$LCG_LR" != "" ] ; then
                    CLOSE_REPLICA="`getCloseReplica ${SOURCE}`"
                    if [ "$CLOSE_REPLICA" != "" ] ; then
                        SOURCE="$CLOSE_REPLICA"
                    else
                        if [ "$GRIDREPLICA" == "yes" ] ; then
                            if [ "$LCG_REP" != "" ] ; then
                                msgOut INFO "Replicating installation files"
                                msgOut INFO "$LCG_REP --vo ${TAGVO} -n 10 -d ${CLOSESE} -P ${REPDEST} ${SOURCE}"
                                $LCG_REP --vo ${TAGVO} -n 10 -d ${CLOSESE} -P ${REPDEST} ${SOURCE}
                                [ $? -ne 0 ] && msgOut WARNING "Replication failed"
                                CLOSE_REPLICA="`getCloseReplica ${SOURCE}`"
                                [ "$CLOSE_REPLICA" != "" ] && SOURCE="$CLOSE_REPLICA"
                            else
                                msgOut WARNING "lcg-rep not found"
                                let getrc=70
                            fi
                        fi
                    fi
                else
                    msgOut WARNING "lcg-lr not found"
                    let getrc=70
                fi
            fi
            if [ "$LCG_CP" != "" ] ; then
                msgOut INFO  "Copying the file using ${SOURCE}"
                msgOut INFO  "Destination is ${DEST}"
                $LCG_CP --vo ${TAGVO} ${SOURCE} ${DEST}
                if [ $? -ne 0 ] ; then
                    msgOut WARNING "Cannot get the file from the grid using ${SOURCE}"
                    msgOut INFO  "Trying using ${DEFSOURCE}"
                    $LCG_CP --vo ${TAGVO} ${DEFSOURCE} ${DEST}
                    if [ $? -ne 0 ] ; then
                        msgOut WARNING "Cannot get the file from the grid using ${DEFSOURCE}"
                        let getrc=80
                    fi
                else
                    msgOut INFO  "Copy OK"
                fi
            else
                msgOut WARNING "lcg-cp not found"
                let getrc=70
            fi
        fi
    else
        msgOut WARNING "lcg-lg not found"
        let getrc=70
    fi
    return $getrc
}

putGridFile() {
    SOURCE="${1}"
    LFN="${2}"
    DESTPATH="install/lcg/`basename $SOURCE`"
    LCG_LG="`which lcg-lg`"
    LCG_CR="`which lcg-cr`"
    GUID=""
    putrc=0
    if [ "$LCG_LG" != "" ] ; then
        GUID="`lcg-lg --vo ${TAGVO} lfn:${LFN} 2>/dev/null`"
        if [ "$GUID" != "" ] ; then
            msgOut WARNING "${LFN} already present in the Grid"
            putrc=90
        fi
    fi
    if [ $putrc -eq 0 ] ; then
        if [ "$LCG_CR" != "" ] ; then
            msgOut INFO "Registering ${SOURCE} in the Grid"
            msgOut INFO "Using LFN ${LFN}"
            [ "$CLOSESE" != "" ] && CLOSESE_OPT="-d $CLOSESE"
            msgOut INFO "CMD: lcg-cr --vo ${TAGVO} -l ${LFN} -P ${DESTPATH} file:${SOURCE} ${CLOSESE_OPT}"
            lcg-cr --vo ${TAGVO} -l ${LFN} -P ${DESTPATH} file:${SOURCE} ${CLOSESE_OPT}
            putrc=$?
            [ $putrc -ne 0 ] && msgOut WARNING "Registration failed"
        else
            msgOut WARNING "lcg-cr not found"
            putrc=70
        fi
    fi
    return $putrc
}

setupDev() {
    SETUP_OPT="${1}"
    LASTCWD=$PWD
    REQFILE=$PWD/cmthome/requirements
    TESTAREA=$PWD/testarea
    msgOut INFO "Creating requirements file ${REQFILE}"
    [ ! -d "`dirname ${REQFILE}`" ] && mkdir -p "`dirname ${REQFILE}`"
    [ ! -d "${TESTAREA}" ] && mkdir -p "${TESTAREA}"
    rm -f ${REQFILE}
    cat > ${REQFILE} <<EORF
set CMTSITE ${CMTSITE}
set SITEROOT ${SITEROOT}
macro ATLAS_DIST_AREA ${SITEROOT}
apply_tag projectArea
macro SITE_PROJECT_AREA ${SITEROOT}
macro EXTERNAL_PROJECT_AREA ${SITEROOT}
apply_tag setup
apply_tag simpleTest
macro ATLAS_TEST_AREA ${TESTAREA}
EORF

    if [ "$PRJTYPE" == "eventview" ] ; then
        cat >> ${REQFILE} <<EORF
macro ATLAS_GROUP_AREA "`dirname ${SWPHYS}`"
EORF
    fi
    cat >> ${REQFILE} <<EORF
use AtlasLogin AtlasLogin-* \$(ATLAS_DIST_AREA)
set CMTCONFIG ${CMTCONFIG}
set DBRELEASE_INSTALLED  $DBRELEASE_INSTALLED
EORF
    crfrc=$?
    if [ $crfrc -eq 0 ] ; then
        msgOut INFO "`cat ${REQFILE}`"
        msgOut INFO "Configuring CMT"
        cd `dirname $REQFILE`
        cmt config
        let crfrc=$crfrc+$?
        if [ $crfrc -eq 0 ] ; then
            msgOut INFO "CMT configuration successful"
            msgOut INFO "Setting up the release from $PWD"
            msgOut INFO "source setup.sh $SETUP_OPT"
            source setup.sh $SETUP_OPT
            msgOut INFO "GroupArea=$GroupArea"
            msgOut INFO "JOBOPTSEARCHPATH=$JOBOPTSEARCHPATH"
        else
            msgOut ERROR "Error during CMT configuration"
        fi
        cd $LASTCWD
    else
        msgOut ERROR "Cannot create ${REQFILE}"
    fi
    return $crfrc
}

snap() {
    SNAPDIR="${1}"
    SNAPDIR_TMP="${SNAPDIR}.tmp.$$"
    SNAPNAME="${2}"
    SNAP="${SNAPDIR}/${SNAPNAME}"
    TAR_NAME=${SNAPNAME}.tar.gz
    NEW_SNAP="no"
    let snaprc=0

    # If the Grid caching is enabled try to get the file from a SE
    if [ "$USEGRID" == "yes" ] ; then
        mkdir -p "${SNAPDIR_TMP}"
        cd "${SNAPDIR_TMP}"
        getGridFile ${CATALOG_PATH}/${TAR_NAME} ${PWD}/${TAR_NAME}
        if [ -s $PWD/$TAR_NAME ] ; then
            msgOut INFO "Snapshot tarball copied to ${PWD}/${TAR_NAME}"
            msgOut INFO "`\ls -l ${PWD}/${TAR_NAME}`"
            tar xfz $TAR_NAME
            if [ $? -ne 0 ] ; then
                msgOut ERROR "Failed to untar the snapshot tarball"
            else
                msgOut INFO "Snapshot tarball unpacked successfully"
                md5sum -c MD5SUM > /dev/null
                if [ $? -ne 0 ] ; then
                    msgOut ERROR "Checksum error in the snapshot files"
                else
                    msgOut INFO "Snapshot checksum OK"
                    rm -fr ${SNAP}*
                    SNAPSHOT="`\ls -d ${SNAPNAME}.snap* 2>/dev/null | tail -n 1`"
                    if [ "$SNAPSHOT" != "" ] ; then
                        [ ! -d "${SNAPDIR}" ] && mkdir -p "${SNAPDIR}"
                        mv ${SNAPSHOT} ${SNAPDIR}
                        msgOut INFO "Snapshot ${SNAPSHOT} moved to ${SNAPDIR}"
                        msgOut INFO "Listing contents of dir ${SNAPDIR}"
                        msgOut INFO "`\ls -l ${SNAPDIR} 2>/dev/null`"
                        msgOut INFO "Listing details of the snapshot"
                        msgOut INFO "`\du -sk -l ${SNAP}.snap* 2>/dev/null`"
                    else
                        msgOut ERROR "Cannot find the snapshot"
                    fi
                fi
            fi
        fi
        cd -
        rm -fr ${SNAPDIR_TMP}
    fi

    # Make the snapshot, if needed
    SNAPSHOT="`\ls -ld ${SNAP}.snap* 2>/dev/null | tail -n 1`"
    if [ "${SNAPSHOT}" == "" ] ; then
        msgOut INFO "Cannot find snapshot called ${SNAP}.snap*"
        msgOut INFO "Downloading and snapshotting"
        msgOut INFO "Snapshot name: `basename ${SNAP}`"
        NEW_SNAP="yes"
        if [ "$PACMAN_OPTS" != "" ] ; then
            pacman $PACMAN_OPTS
            if [ `echo $PACMAN_VER | awk -F. '{printf "%d%02d%02d",$1,$2,$3}'` -lt 31800 ] ; then
                pacman -v down tar up
            else
                pacman -v download tar up
            fi
            pacman -def
        fi
        TMPAREA="${TOPDIR}/tmp.$$"
        TMPDIR="/tmp/atlas-install-$PRJNAME-$RELEASE"
        mkdir -p "${TMPAREA}"
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot create ${TMPAREA}"
            return $snaprc
        fi
        ln -sf ${TMPAREA} ${TMPDIR}
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot link ${TMPAREA} to ${TMPDIR}"
            return $snaprc
        fi
        let snaprc=$snaprc+$?
        cd "${TMPDIR}"
        if [ "$PACKOPT" == "all" ] ; then
            echo y | pacman $PACMAN_OPTS -fetch \
                     ${LCGCACHE}:${RELEASE}/${GCC}
            let snaprc=$snaprc+$?
            echo y | pacman $PACMAN_OPTS -fetch \
                     ${LCGCACHE}:${RELEASE}/${KV}
            let snaprc=$snaprc+$?
        fi
        echo "pacman $PACMAN_OPTS -fetch \"${ATLAS}:${ATLASRELEASE}\""
        echo y | pacman $PACMAN_OPTS -fetch "${ATLAS}:${ATLASRELEASE}"
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot fetch ${ATLAS}:${ATLASRELEASE}"
            return $snaprc
        fi
        if [ "$EXTRPKG" != "" ] ; then
            echo "pacman $PACMAN_OPTS -fetch ${ATLAS}:${EXTRAPKG}"
            echo y | pacman $PACMAN_OPTS -fetch ${ATLAS}:${EXTRAPKG}
            let snaprc=$snaprc+$?
            if [ $snaprc -ne 0 ] ; then
                msgOut ERROR "Cannot fetch ${ATLAS}:${EXTRAPKG}"
                return $snaprc
            fi
        fi
        [ ! -d "${SNAPDIR}" ] && mkdir -p "${SNAPDIR}"
        pacman -snap -o "${SNAP}" .
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot create the snapshot ${SNAP}"
            return $snaprc
        fi
        cd "${TOPDIR}"
        # Clean up the temporary directory and link
        rm -fr ${TMPDIR}
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot remove the temporary link ${TMPDIR}"
            return $snaprc
        fi
        rm -fr ${TMPAREA}
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot remove the temporary area ${TMPAREA}"
            return $snaprc
        fi

        # Register the tarball to the Grid, if required
        if [ "$USEGRID" == "yes" -a "$NEW_SNAP" == "yes" ] ; then
            cd "$SNAPDIR"
            # Checksums
            msgOut INFO "Calculating checksums"
            \find ${SNAPNAME}.* -type f -exec md5sum {} \; > MD5SUM
            let snaprc=$snaprc+$?
            # Create the tarball
            msgOut INFO "Creating the installation tarball"
            tar cfz ${TAR_NAME} ${SNAPNAME}.* MD5SUM
            let snaprc=$snaprc+$?
            if [ $snaprc -eq 0 ] ; then
                msgOut INFO "Registering the installation tarball to the Grid"
                putGridFile $PWD/${TAR_NAME} ${CATALOG_PATH}/${TAR_NAME}
            else
                msgOut ERROR "Cannot create ${TAR_NAME}"
            fi
            if [ -s "${TAR_NAME}" ] ; then
                msgOut INFO "Removing ${TAR_NAME}"
                rm -fr "${TAR_NAME}"
            fi
        fi
    else
        msgOut INFO "Snapshot found: ${SNAPSHOT}"
    fi
    msgOut INFO "Snapshot processing OK"
    return $snaprc
}

pacball() {
    PBDIR="${1}"
    PBDIR_TMP="${PBDIR}.tmp.$$"
    PBNAME="${2}"
    PB="${PBDIR}/${PBNAME}"
    TAR_NAME=${PBNAME}.tar.gz
    NEW_PB="no"
    let pbrc=0

    # If the Grid caching is enabled try to get the file from a SE
    if [ "$USEGRID" == "yes" ] ; then
        mkdir -p "${PBDIR_TMP}"
        cd "${PBDIR_TMP}"
        getGridFile ${CATALOG_PATH}/${TAR_NAME} ${PWD}/${TAR_NAME}
        if [ -s $PWD/$TAR_NAME ] ; then
            msgOut INFO "Pacball copied to ${PWD}/${TAR_NAME}"
            msgOut INFO "`\ls -l ${PWD}/${TAR_NAME}`"
            tar xfz $TAR_NAME
            if [ $? -ne 0 ] ; then
                msgOut ERROR "Failed to untar the pacball"
            else
                msgOut INFO "Pacball unpacked successfully"
                md5sum -c MD5SUM > /dev/null
                if [ $? -ne 0 ] ; then
                    msgOut ERROR "Checksum error in the pacball files"
                else
                    msgOut INFO "Pacball checksum OK"
                    rm -fr ${PB}*
                    PB="`\ls -d ${PBNAME} 2>/dev/null | tail -n 1`"
                    if [ "$PB" != "" ] ; then
                        [ ! -d "${PBDIR}" ] && mkdir -p "${PBDIR}"
                        mv ${PB} ${PBDIR}
                        msgOut INFO "Pacball ${PB} moved to ${PBDIR}"
                        msgOut INFO "Listing contents of dir ${PBDIR}"
                        msgOut INFO "`\ls -l ${PBDIR} 2>/dev/null`"
                        msgOut INFO "Listing details of the pacball"
                        msgOut INFO "`\du -sk -l ${PB} 2>/dev/null`"
                    else
                        msgOut ERROR "Cannot find the pacball"
                    fi
                fi
            fi
        fi
        cd -
        rm -fr ${PBDIR_TMP}
    fi

    # Make the pacball, if needed
    PACBALL="`\ls -ld ${PB} 2>/dev/null | tail -n 1`"
    if [ "${PACBALL}" == "" ] ; then
        msgOut INFO "Cannot find any pacball called ${PB}"
        msgOut INFO "Downloading and creating the pacball"
        msgOut INFO "Pacball name: `basename ${PB}`"
        NEW_PB="yes"
        if [ "$PACMAN_OPTS" != "" -a "$USEPACBALL" != "yes" ] ; then
            pacman $PACMAN_OPTS
            if [ `echo $PACMAN_VER | awk -F. '{printf "%d%02d%02d",$1,$2,$3}'` -lt 31800 ] ; then
                pacman -v down tar up
            else
                pacman -v download tar up
            fi
            pacman -def
        fi
        TMPAREA="${TOPDIR}/tmp.$$"
        TMPDIR="/tmp/atlas-install-$PRJNAME-$RELEASE"
        mkdir -p "${TMPAREA}"
        let pbrc=$pbrc+$?
        if [ $pbrc -ne 0 ] ; then
            msgOut ERROR "Cannot create ${TMPAREA}"
            return $pbrc
        fi
        ln -sf ${TMPAREA} ${TMPDIR}
        let pbrc=$pbrc+$?
        if [ $pbrc -ne 0 ] ; then
            msgOut ERROR "Cannot link ${TMPAREA} to ${TMPDIR}"
            return $pbrc
        fi
        let pbrc=$pbrc+$?
        cd "${TMPDIR}"
        [ ! -d "${PB}" ] && mkdir -p "${PB}"
        if [ "$PACKOPT" == "all" ] ; then
            echo y | pacman $PACMAN_OPTS -pacball \
                     ${LCGCACHE}:${RELEASE}/${GCC}
            let pbrc=$pbrc+$?
            mv ${GCC}.*.sh ${PB} 2> /dev/null
            echo y | pacman $PACMAN_OPTS -pacball \
                     ${LCGCACHE}:${RELEASE}/${KV}
            let pbrc=$pbrc+$?
            mv ${KV}.*.sh ${PB} 2> /dev/null
        fi
        echo "pacman $PACMAN_OPTS -pacball ${ATLAS}:${ATLASRELEASE}"
        echo y | pacman $PACMAN_OPTS -pacball ${ATLAS}:${ATLASRELEASE}
        let pbrc=$pbrc+$?
        if [ $pbrc -ne 0 ] ; then
            msgOut ERROR "Cannot create the pacball for ${ATLAS}:${ATLASRELEASE}"
            return $pbrc
        fi
        mv ${ATLASRELEASE}.*.sh ${PB} 2> /dev/null
        if [ "$EXTRPKG" != "" ] ; then
            echo "pacman $PACMAN_OPTS -pacball ${ATLAS}:${EXTRAPKG} -o ${PB}/${EXTRAPKG}"
            echo y | pacman $PACMAN_OPTS -pacball ${ATLAS}:${EXTRAPKG} -o ${PB}/${EXTRAPKG}
            let pbrc=$pbrc+$?
            if [ $pbrc -ne 0 ] ; then
                msgOut ERROR "Cannot create the pacball for ${ATLAS}:${EXTRAPKG}"
                return $pbrc
            fi
        fi
        if [ $pbrc -ne 0 ] ; then
            msgOut ERROR "Cannot create the pacball ${PB}"
            return $pbrc
        fi
        cd "${TOPDIR}"
        # Clean up the temporary directory and link
        rm -fr ${TMPDIR}
        let pbrc=$pbrc+$?
        if [ $pbrc -ne 0 ] ; then
            msgOut ERROR "Cannot remove the temporary link ${TMPDIR}"
            return $pbrc
        fi
        rm -fr ${TMPAREA}
        let pbrc=$pbrc+$?
        if [ $pbrc -ne 0 ] ; then
            msgOut ERROR "Cannot remove the temporary area ${TMPAREA}"
            return $pbrc
        fi

        # Register the tarball to the Grid, if required
        if [ "$USEGRID" == "yes" -a "$NEW_SNAP" == "yes" ] ; then
            cd "$SNAPDIR"
            # Checksums
            msgOut INFO "Calculating checksums"
            \find ${PBNAME}.* -type f -exec md5sum {} \; > MD5SUM
            let pbrc=$pbrc+$?
            # Create the tarball
            msgOut INFO "Creating the installation tarball"
            tar cfz ${TAR_NAME} ${PBNAME}.* MD5SUM
            let pbrc=$pbrc+$?
            if [ $pbrc -eq 0 ] ; then
                msgOut INFO "Registering the installation tarball to the Grid"
                putGridFile $PWD/${TAR_NAME} ${CATALOG_PATH}/${TAR_NAME}
            else
                msgOut ERROR "Cannot create ${TAR_NAME}"
            fi
            if [ -s "${TAR_NAME}" ] ; then
                msgOut INFO "Removing ${TAR_NAME}"
                rm -fr "${TAR_NAME}"
            fi
        fi
    else
        msgOut INFO "Pacball container found: ${PB}"
    fi
    msgOut INFO "Pacball processing OK"
    return $pbrc
}

prepareInstallDirs() {
    # Check the installation directories
    if [ "$SWPATH" != "" ] ; then
        [ ! -d $SWPATH ] && mkdir -p "${SWPATH}"
    fi
    [  ! -d ${RELLOC} ] && mkdir -p "${RELLOC}"
    if [ ! -d ${SWLOC} -a "${PRJTYPE}" != "patch" -a "${PRJTYPE}" != "p1patch" -a "$PRJTYPE" != "eventview" ] ; then
        msgOut ERROR "Missing logical installation dir (${SWLOC}). Trying to create it."
        mkdir -p "${SWLOC}"
        if [  $? -ne 0  ] ; then
            msgOut ERROR "Cannot create ${SWLOC}."
            return 120
        else
            msgOut INFO "Logical installation dir created successfully."
        fi
    fi
    if [ ! -d ${RELLOC} ] ; then
        msgOut ERROR "Missing physical installation dir (${RELLOC}). Trying to create it."
        mkdir -p "${RELLOC}"
        if [  $? -ne 0  ] ; then
            msgOut ERROR "Cannot create ${RELLOC}."
            return 121
        else
            msgOut INFO "Physical installation dir created successfully."
        fi
    fi
    return 0
}


install() {
    cd ${TOPDIR}
    let instrc=0
    SWPHYS=${RELLOC}
    SWLOG=${SWLOC}
    if [ "${SWPATH}" != "" ] ; then
        SWPHYS="$SWPATH"
        SWLOG="$SWPATH"
    fi
    LOCKFILE=${SWPHYS}/atlas-install.lock

    # Wait for previous installation process completion
    if [ -f ${LOCKFILE} ] ; then
        msgOut WARNING "Another installation process is currently active. Now waiting..."
        waittime=0
        while `test -f ${LOCKFILE}`; do
            sleep 1s
            let waittime=$waittime+1
            if [ $waittime -gt 3600 ] ; then
                msgOut WARNING "Timeout [3600 s]"
                msgOut WARNING "Removing stale installation lock"
                rm -f ${LOCKFILE}
            fi
        done
    fi
    msgOut INFO "Locking the installation area"
    echo "$RELEASE installation lock" > ${LOCKFILE}
    case `whoami` in
        *[0-9])
            msgOut INFO "This site is configured for SGM pool accounts. Changing group permissions to ${LOCKFILE}"
            chmod -R g+w ${LOCKFILE} 2>/dev/null
            [ $? -ne 0 ] && msgOut ERROR "Cannot change group write permissions to ${LOCKFILE}"
        ;;
    esac

    # Installation options
    if [ "$NOCACHE" == "yes" ] ; then
        RELSNAP=${ATLAS}
        GCCSNAP=${LCGCACHE}
        KVSNAP=${LCGCACHE}
    else
        if [ "$USEPACBALL" != "yes" ] ; then
            SNAPN=${SWPHYS}/atlas-install.snapshot
            snap "${SNAPDIR}" "${SNAPNAME}"
        else
            SNAPN=${SWPHYS}/atlas-install.pacball
            pacball "${SNAPDIR}" "${SNAPNAME}"
        fi
        RELSNAP=${SNAPN}
        GCCSNAP=${SNAPN}
        KVSNAP=${SNAPN}
        let instrc=$instrc+$?
        if [ $instrc -eq 0 ] ; then
            if [ "$USEPACBALL" != "yes" ] ; then
                SNAPSHOT="`\ls -d ${SNAPDIR}/${SNAPNAME}*snap* 2>/dev/null | tail -n 1`"
                if [ "$SNAPSHOT" != "" ] ; then
                    msgOut INFO "Using snapshot ${SNAPSHOT}"
                    msgOut INFO "Linking snapshot to ${SNAPN}"
                    ln -sf ${SNAPSHOT} ${SNAPN}
                    msgOut INFO "`ls -l ${SNAPN}`"
                else
                    msgOut ERROR "Cannot find any snapshot called ${SNAPDIR}/${SNAPNAME}*snap*"
                    msgOut INFO "Unlocking the installation area"
                    rm -f ${LOCKFILE}
                    return 110
                fi
            else
                PB="`\ls -d ${SNAPDIR}/${SNAPNAME} 2>/dev/null | tail -n 1`"
                if [ "$PB" != "" ] ; then
                    msgOut INFO "Using pacball ${PB}"
                    msgOut INFO "Linking pacball to ${SNAPN}"
                    ln -sf ${PB} ${SNAPN}
                    msgOut INFO "`ls -l ${SNAPN}`"
                else
                    msgOut ERROR "Cannot find any pacball called ${SNAPDIR}/${PB}"
                    msgOut INFO "Unlocking the installation area"
                    rm -f ${LOCKFILE}
                    return 110
                fi
            fi
        else
            msgOut INFO "Unlocking the installation area"
            rm -f ${LOCKFILE}
            return $instrc
        fi
    fi

    # Check the installation dirs
    prepareInstallDirs
    instrc=$?
    if [ $instrc -ne 0 ] ; then
        msgOut ERROR "Skipping the installation task."
        msgOut INFO "Unlocking the installation area"
        rm -f ${LOCKFILE}
        return $instrc
    fi

    # Handle the patches to releases and EventView caches
    if [ "${PRJTYPE}" == "patch" -o "${PRJTYPE}" == "p1patch" -o "${PRJTYPE}" == "p1nightly" -o "${PRJTYPE}" == "eventview" ] ; then
        MAINRELEASE="`echo $RELEASE | cut -d "." -f 1-3`"
        RELMAJOR="`echo $RELEASE | cut -d "." -f 1`"
        if [ $RELMAJOR -lt 12 ] ; then
            msgOut ERROR "Installation of patches or PAT tools not supported for releases < 12.0.0"
            msgOut INFO "Unlocking the installation area"
            rm -f ${LOCKFILE}
            return 130
        fi
        if [ ! -s ${RELLOC}/cmtsite/setup.sh ] ; then
            msgOut ERROR "No $MAINRELEASE release setup file found. Please install $MAINRELEASE first."
            msgOut INFO "Unlocking the installation area"
            rm -f ${SNAPN}
            rm -f ${LOCKFILE}
            return 131
        fi
        # Setup the main release
        msgOut INFO "Trying to setup release $MAINRELEASE."
        [ "${REQPRJNAME}" != "" ] && RPNAME="${REQPRJNAME}" || RPNAME="${PRJNAME}"
        msgOut INFO "source ${RELLOC}/cmtsite/setup.sh -tag=${MAINRELEASE},${RPNAME},${PRJOPT}"
        source ${RELLOC}/cmtsite/setup.sh -tag=${MAINRELEASE},${RPNAME},${PRJOPT}
        if [ ! -d ${CMTPATH} ] ; then
            msgOut ERROR "${RPNAME} $MAINRELEASE not found in $RELLOC. Please install release $MAINRELEASE first."
            msgOut INFO "Unlocking the installation area"
            rm -f ${SNAPN}
            rm -f ${LOCKFILE}
            return 132
        else
            msgOut INFO "${RPNAME} ${MAINRELEASE} found in $SITEROOT."
        fi
    fi

    # Start the installation
    cd "${SWPHYS}"
    msgOut INFO "Starting the installation"
    msgOut INFO "Installation type: ${PRJNAME}"
    msgOut INFO "PATH=${PATH}"
    msgOut INFO "Physical area: ${SWPHYS}"
    [ "${PRJTYPE}" != "patch" -a "${PRJTYPE}" != "p1patch" -a "${PRJTYPE}" != "eventview" ] && msgOut INFO "Logical area:  ${SWLOG}"
    msgOut INFO "Starting physical installation in ${PWD}"
    if [ "$DEBUG" == "yes" ] ; then
        msgOut DEBUG "PATH=${PATH}"
        msgOut DEBUG "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
        msgOut DEBUG "PYTHONPATH=${PYTHONPATH}"
    fi
    if [ "$PACMAN_OPTS" != "" -a "$USEPACBALL" != "yes" ] ; then
        msgOut INFO "pacman $PACMAN_OPTS"
        pacman $PACMAN_OPTS
        let instrc=$instrc+$?
        if [ `echo $PACMAN_VER | awk -F. '{printf "%d%02d%02d",$1,$2,$3}'` -lt 31800 ] ; then
            pacman -v down tar up
        else
            msgOut INFO "pacman -v download tar up $PACMAN_OPTS"
            pacman -v download tar up $PACMAN_OPTS
        fi
        let instrc=$instrc+$?
        pacman -def
        let instrc=$instrc+$?
    fi
    rm -f *.tar

    if [ "$PACKOPT" == "all" -a "$USEPACBALL" != "yes" ] ; then
        # Install the compiler for this release
        PACMAN_CMD="-get ${GCCSNAP}:${RELEASE}/${GCC}"
        [ "$UPDATE" == "yes" ] && PACMAN_CMD="$PACMAN_CMD -update ${GCCSNAP}:${RELEASE}/${GCC}"
        msgOut INFO "Executing pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
        echo y | \
        pacman ${PACMAN_OPTS} ${PACMAN_CMD}
        let instrc=$instrc+$?
        source setup.sh
    fi
    # Install the selected extra packages
    if [ "$EXTRAPKG" != "" ] ; then
        PACMAN_CMD="-get ${RELSNAP}:${EXTRAPKG}"
        [ "$UPDATE" == "yes" ] && PACMAN_CMD="$PACMAN_CMD -update ${RELSNAP}:${EXTRAPKG}"
        msgOut INFO "Executing pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
        echo y | \
        pacman ${PACMAN_OPTS} ${PACMAN_CMD}
        let instrc=$instrc+$?
        if [ $instrc -ne 0 ] ; then
            msgOut ERROR "Physical area installation FAILED"
            msgOut ERROR "`pacman -last 2>&1`"
            OFFENDINGPKG="`pacman -last 2>&1 | grep -i 'has not been installed' | sed 's/\(.*\)\[\(.*\)\].*/\2/' | awk -F':' '{print $NF}'`"
            if [ "$OFFENDINGPKG" != "" ] ; then
                msgOut WARNING "Trying to remove the offending package $OFFENDINGPKG"
                pacman ${PACMAN_OPTS} -remove ${OFFENDINGPKG}
                if [ $? -eq 0 ] ; then
                    msgOut INFO "Offending package removed successfully. Now retrying pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                    pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                    let instrc=$?
                else
                    msgOut ERROR "Cannot remove the offending package $OFFENDINGPKG"
                    msgOut ERROR "`pacman -last 2>&1`"
                fi
            fi
            if [ $instrc -ne 0 ] ; then
                msgOut ERROR "Physical area installation FAILED"
                msgOut ERROR "`pacman -last 2>&1`"
                msgOut INFO "Unlocking the installation area"
                rm -f ${LOCKFILE}
                return $instrc
            fi
        fi
    fi
    # Install the selected release
    if [ "$USEPACBALL" != "yes" ] ; then
        PACMAN_CMD="-get \"${RELSNAP}:${ATLASRELEASE}\""
        [ "$UPDATE" == "yes" ] && PACMAN_CMD="$PACMAN_CMD -update ${RELSNAP}:${ATLASRELEASE}"
        msgOut INFO "Executing pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
        echo y | \
          eval pacman ${PACMAN_OPTS} ${PACMAN_CMD}
        let instrc=$instrc+$?
    else
        ATLASRELEASEFNAME="`\ls -d ${RELSNAP}/${ATLASRELEASE}.*.sh 2>/dev/null`"
        if [ "$ATLASRELEASEFNAME" != "" ] ; then
            msgOut INFO "Executing /bin/bash ${ATLASRELEASEFNAME}"
            /bin/bash ${ATLASRELEASEFNAME}
            let instrc=$instrc+$?
        else
            msgOut ERROR "Cannot find ${RELSNAP}/${ATLASRELEASE}.*.sh"
            let instrc=$instrc+15
        fi
    fi
    if [ $instrc -ne 0 ] ; then
        msgOut ERROR "Physical area installation FAILED"
        msgOut ERROR "`pacman -last 2>&1`"
        OFFENDINGPKG="`pacman -last 2>&1 | grep -i 'has not been installed' | sed 's/\(.*\)\[\(.*\)\].*/\2/' | awk -F':' '{print $NF}'`"
        if [ "$OFFENDINGPKG" != "" ] ; then
            msgOut WARNING "Trying to remove the offending package $OFFENDINGPKG"
            pacman ${PACMAN_OPTS} -remove ${OFFENDINGPKG}
            if [ $? -eq 0 ] ; then
                msgOut INFO "Offending package removed successfully. Now retrying pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                let instrc=$?
            else
                msgOut ERROR "Cannot remove the offending package $OFFENDINGPKG"
                msgOut ERROR "`pacman -last 2>&1`"
            fi
        fi
        if [ $instrc -ne 0 ] ; then
            msgOut ERROR "Physical area installation FAILED"
            msgOut ERROR "`pacman -last 2>&1`"
            msgOut INFO "Unlocking the installation area"
            rm -f ${LOCKFILE}
            return $instrc
        fi
    fi
    # Clean snapshots
    pacman -clear-snapshots
    # DB release
    if [ "$DBREL" != "" ] ; then
        # Check and fix the "DBRelease" directory if we are not the owners
        DBRELFIX="DBRelease"
        if [ -d DBRelease -a "`ls -ld $DBRELFIX 2>/dev/null | awk '{print $3}'`" != "`whoami`" ] ; then
            msgOut INFO "Fixing the $DBRELFIX directory to be able to write there"
            cp -a ${DBRELFIX} ${DBRELFIX}.new
            if [ $? -eq 0 ] ; then
                cd ${DBRELFIX}
                find . -type f -exec md5sum {} \; > ../MD5SUM
                cd ../${DBRELFIX}.new
                md5sum -c ../MD5SUM > /dev/null
                dbrf_rc=$?
                cd ..
                rm -f MD5SUM
                if [ $dbrf_rc -eq 0 ] ; then
                    mv ${DBRELFIX} ${DBRELFIX}.old
                    mv ${DBRELFIX}.new ${DBRELFIX}
                    rm -fr ${DBRELFIX}.old
                    msgOut INFO "$DBRELFIX successfully fixed"
                else
                    msgOut ERROR "Fixed $DBRELFIX differs from the original. Keeping the original copy."
                    rm -fr ${DBRELFIX}.new
                fi
            else
                msgOut ERROR "Cannot fix $DBRELFIX"
            fi
        fi
        # Perform the DBRelease installation
        PACMAN_CMD="-get ${DBRELCACHE}:${DBRELPKG}"
        msgOut INFO "Executing pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
        echo y | \
        pacman ${PACMAN_OPTS} ${PACMAN_CMD}
        let instrc=$instrc+$?
        if [ $instrc -ne 0 ] ; then
            msgOut ERROR "DB release installation FAILED"
            msgOut ERROR "`pacman -last 2>&1`"
            OFFENDINGPKG="`pacman -last 2>&1 | grep -i 'has not been installed' | sed 's/\(.*\)\[\(.*\)\].*/\2/' | awk -F':' '{print $NF}'`"
            if [ "$OFFENDINGPKG" != "" ] ; then
                msgOut WARNING "Trying to remove the offending package $OFFENDINGPKG"
                pacman ${PACMAN_OPTS} -remove ${OFFENDINGPKG}
                if [ $? -eq 0 ] ; then
                    msgOut INFO "Offending package removed successfully. Now retrying pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                    pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                    let instrc=$?
                else
                    msgOut ERROR "Cannot remove the offending package $OFFENDINGPKG"
                    msgOut ERROR "`pacman -last 2>&1`"
                fi
            fi
            if [ $instrc -ne 0 ] ; then
                msgOut ERROR "Physical area installation FAILED"
                msgOut ERROR "`pacman -last 2>&1`"
            fi
        fi
    fi
    # Create the logical installation for the selected release
    if [ "${PRJTYPE}" != "patch" -a "${PRJTYPE}" != "p1patch" -a "${PRJTYPE}" != "eventview" ] ; then
        cd "${SWLOG}"
        msgOut INFO "Starting logical installation in ${PWD}"
        SWLOCBD="`date +%s`"
        rm -fr *
        if [ "$PACKOPT" == "all" -a "$USEPACBALL" != "yes" ] ; then
            echo y | \
            pacman ${PACMAN_OPTS} \
                   -get ${RELLOC}:${RELEASE}/${GCC}
            let instrc=$instrc+$?
            echo y | \
            pacman ${PACMAN_OPTS} \
                   -get ${KVSNAP}:${RELEASE}/${KV}
            let instrc=$instrc+$?
        fi
        PACMAN_CMD="-get ${RELLOC}:${ATLASRELEASE}"
        [ "$UPDATE" == "yes" ] && PACMAN_CMD="$PACMAN_CMD -update ${RELLOC}:${ATLASRELEASE}"
        msgOut INFO "Executing pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
        echo y | \
        pacman ${PACMAN_OPTS} ${PACMAN_CMD}
        let instrc=$instrc+$?
        SWLOCED="`date +%s`"
        msgOut INFO "Logical area installation completed in `echo $SWLOCED-$SWLOCBD | bc` s"
        if [ $instrc -ne 0 ] ; then
            msgOut ERROR "Logical area installation FAILED"
            msgOut ERROR "`pacman -last 2>&1`"
            OFFENDINGPKG="`pacman -last 2>&1 | grep -i 'has not been installed' | sed 's/\(.*\)\[\(.*\)\].*/\2/' | awk -F':' '{print $NF}'`"
            if [ "$OFFENDINGPKG" != "" ] ; then
                msgOut WARNING "Trying to remove the offending package $OFFENDINGPKG"
                pacman ${PACMAN_OPTS} -remove ${OFFENDINGPKG}
                if [ $? -eq 0 ] ; then
                    msgOut INFO "Offending package removed successfully. Now retrying pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                    pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                    let instrc=$?
                else
                    msgOut ERROR "Cannot remove the offending package $OFFENDINGPKG"
                    msgOut ERROR "`pacman -last 2>&1`"
                fi
            fi
            if [ $instrc -ne 0 ] ; then
                msgOut ERROR "Physical area installation FAILED"
                msgOut ERROR "`pacman -last 2>&1`"
                msgOut INFO "Unlocking the installation area"
                rm -f ${LOCKFILE}
                return $instrc
            fi
        fi
        pacman -clear-snapshots
    fi
    rm -f $SNAPN
    [ "$TEMPCACHE" == "yes" ] && rm -fr ${SNAPDIR}/${SNAPNAME}*
    # Post-install steps
    shift $#
    # Set the correct file permissions for the sw areas
    msgOut INFO "Removing write permission to all users from ${SWPHYS}"
    find ${SWPHYS} -user `whoami` | sed -e "s/^/'/g" -e "s/$/'/g" | xargs chmod -R o-w 2>/dev/null
    msgOut INFO "Removing write permission to all users from ${SWLOG}"
    find ${SWLOG} -user `whoami` | sed -e "s/^/'/g" -e "s/$/'/g" | xargs chmod -R o-w 2>/dev/null
    case `whoami` in
        *[0-9])
            msgOut INFO "This site is configured for SGM pool accounts"
            msgOut INFO "Setting write permission to group \"`id -gn`\" on ${SWPHYS}"
            find ${SWPHYS} -user `whoami` | sed -e "s/^/'/g" -e "s/$/'/g" | xargs chmod -R g+w 2>/dev/null
            [ $? -ne 0 ] && msgOut ERROR "Cannot change group write permissions to ${SWPHYS}"
            msgOut INFO "Setting write permission to group \"`id -gn`\" on ${SWLOG}"
            find ${SWLOG} -user `whoami` | sed -e "s/^/'/g" -e "s/$/'/g" | xargs chmod -R g+w 2>/dev/null
            [ $? -ne 0 ] && msgOut ERROR "Cannot change group write permissions to ${SWLOG}"
            if [ "$DUMPTAGS" != "" ] ; then
                chmod g+w $DUMPTAGS 2>/dev/null
                [ $? -ne 0 ] && msgOut ERROR "Cannot change group write permissions to ${DUMPTAGS}"
            fi
            ;;
        *) msgOut INFO "This site is configured for SGM static accounts. No further action required"
            ;;
    esac
    # Perform other ATLAS sw specific post-install steps. Exclude external packages and EventView caches.
    cd "${SWLOG}"
    if [ "$PRJTYPE" != "ext" -a "${PRJTYPE}" != "eventview" ] ; then
        if [ "$PRJNAME" == "release" -o "$PRJNAME" == "AtlasRelease" ] ; then
            source setup.sh
            msgOut INFO "Setting up runtime enviroment from ${SITEROOT}/dist/${RELEASE}/Control/AthenaRunTime"
            cd ${SITEROOT}/dist/${RELEASE}/Control/AthenaRunTime/*/cmt
            source setup.sh
        else
            if [ -s ${RELLOC}/cmtsite/setup.sh ] ; then
                if [ ! -L cmtsite ] ; then
                    msgOut INFO "Creating $PWD/cmtsite link"
                    ln -sf . cmtsite
                fi
                if [ "${PRJTYPE}" != "patch" -a "${PRJTYPE}" != "p1patch" ] ; then
                    source ${RELLOC}/cmtsite/setup.sh -tag=${RELEASE},${PRJNAME},${PRJOPT}
                    COMPILER_VER="`echo ${ARCH} | sed 's/^_//g' | cut -d'_' -f 3 | sed 's/gcc//g'`"
                    COMPILER_PATH="$VO_ATLAS_SW_DIR"
                    [ "$VO_ATLAS_SW_DIR" == "" ] && COMPILER_PATH="`echo ${SWLOG} ${SWPHYS} | awk '{split($1,a,"/"); split ($2,b,"/"); for (i=2;i<length(a);i++) {if (a[i]==b[i]) printf "/%s", a[i];}}'`"
cat > setup-release.sh <<EOSR
CMD_OPT="\$*"
if [ "\$CMD_OPT" = "" ] ; then
    CMD_OPT="-tag=${RELEASE},${PRJNAME},${PRJOPT},runtime"
    echo "Using default options \$CMD_OPT"
fi
source $SITEROOT/cmtsite/setup.sh \$CMD_OPT
COMPILER="\`/bin/ls -d $COMPILER_PATH/gcc/${COMPILER_VER}* 2>/dev/null | tail -n 1\`"
if [ "\$COMPILER" != "" ] ; then
    source \$COMPILER/setup.sh
    echo "Getting compiler from \$COMPILER"
    echo "\`which gcc\`"
    echo "\`gcc -v\`"
else
    echo "No alt compiler found in $COMPILER_PATH/gcc. Using the system compiler"
fi
EOSR
cat > setup-release.csh <<EOSR
set CMD_OPT="\$*"
if ( "x\$CMD_OPT" == "x" ) then
    set CMD_OPT="-tag=${RELEASE},${PRJNAME},${PRJOPT},runtime"
    echo "Using default options \$CMD_OPT"
endif
source $SITEROOT/cmtsite/setup.csh \$CMD_OPT
set COMPILER="\`/bin/ls -d $COMPILER_PATH/gcc/${COMPILER_VER}* 2>/dev/null | tail -n 1\`"
if ( "x\$COMPILER" != "x" ) then
    source \$COMPILER/setup.sh
    echo "Getting compiler from \$COMPILER"
    echo "\`which gcc\`"
    echo "\`gcc -v\`"
else
    echo "No alt compiler found in $COMPILER_PATH/gcc. Using the system compiler"
fi
EOSR
                    grep -v "source $PWD/setup-release.sh"  setup.sh | \
                            grep -v "source $SITEROOT/cmtsite/setup.sh"  > setup.sh.tmp
                    grep -v "source $PWD/setup-release.csh" setup.csh | \
                            grep -v "source $SITEROOT/cmtsite/setup.csh" > setup.csh.tmp
                    echo "source $PWD/setup-release.sh \$*"  >> setup.sh.tmp
                    echo "source $PWD/setup-release.csh \$*"  >> setup.csh.tmp
                    \mv -f setup.sh.tmp setup.sh
                    \mv -f setup.csh.tmp setup.csh
                else
                    # Check if the patch number is in AtlasLogin and add it if needed
                    RELBASE="`echo $RELEASE | cut -d. -f 1-3`"
                    msgOut INFO "Checking the AtlasLogin requirements (source ${RELLOC}/cmtsite/setup.sh -tag=${RELBASE},${REQPRJNAME},${PRJOPT})"
                    source ${RELLOC}/cmtsite/setup.sh -tag=${RELBASE},${REQPRJNAME},${PRJOPT}
                    ATLASLOGINREQ="`\find $SITEROOT/AtlasLogin -name "requirements" | tail -n 1`"
                    grep -q  $RELEASE $ATLASLOGINREQ
                    if [ $? -ne 0 ] ; then
                        msgOut INFO "Adding $RELEASE to the AtlasLogin requirements ($ATLASLOGINREQ)"
                        LATESTPATCH="`grep ".*$RELBASE.*\\"$RELBASE.*\\"" $ATLASLOGINREQ | awk '{print $1}' | grep ^$RELBASE | tail -n 1`"
                        mv -f ${ATLASLOGINREQ} ${ATLASLOGINREQ}.orig
                        AWKCMD="{print \$0;if (/$LATESTPATCH.*\"$LATESTPATCH\"/) {gsub(/$LATESTPATCH/,\"$RELEASE\",\$0);print \$0;}}"
                        cat ${ATLASLOGINREQ}.orig | awk "$AWKCMD" > ${ATLASLOGINREQ}
                    else
                        msgOut INFO "$RELEASE already present in the AtlasLogin requirements ($ATLASLOGINREQ)"
                    fi
                fi
                if [ -d $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime/cmt ] ; then
                    msgOut INFO "Setting up runtime enviroment from $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime"
                    cd $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime/cmt
                    if [ ! -s setup.sh ] ; then
                        msgOut WARNING "No setup file found. Trying to configure..."
                        cd $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}Release/cmt
                        cmt -quiet br - 'cmt -quiet -no_cleanup config'
                        cd $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime/cmt
                        if [ ! -s setup.sh ] ; then
                            msgOut ERROR "Cannot configure the package"
                        else
                            source setup.sh
                        fi
                    else
                        source setup.sh
                    fi
                else
                    msgOut INFO "Cannot setup runtime enviroment from $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime"
                fi
            else
                msgOut ERROR "Cannot find setup file ${RELLOC}/cmtsite/setup.sh"
                let instrc=$instrc+1
            fi
        fi
    fi
    if [ $instrc -eq 0 ] ; then
        if [ "$PRJTYPE" != "ext" -a "$PRJTYPE" != "eventview" ] ; then
            SealPluginRefresh
            cmt build library_links
        fi
        # Set the required environment variables in the setup scripts
        cd "${SWLOG}"
        for setvar in `echo $SETENV | sed 's/,/ /g'`; do
            msgOut INFO "Setting $setvar in $PWD/setup.sh"
            VAREXPORTSH="export $setvar"
            VAREXPORTCSH="setenv `echo $setvar | sed 's/=/ /g'`"
            grep -v "$VAREXPORTSH"  setup.sh > setup.sh.tmp
            grep -v "$VAREXPORTCSH" setup.csh > setup.csh.tmp
            echo "$VAREXPORTSH"  >> setup.sh.tmp
            echo "$VAREXPORTCSH" >> setup.csh.tmp
            \mv -f setup.sh.tmp setup.sh
            \mv -f setup.csh.tmp setup.csh
        done
        cd ${SWPHYS}
        msgOut INFO "Installation OK"
    fi
    msgOut INFO "Unlocking the installation area"
    rm -f ${LOCKFILE}
    cd ${TOPDIR}
    return $instrc
}


validate() {
    let validrc=0
    # Reset the environment
    ENVLAST="/tmp/sw-mgr-envlast.tmp.$$"
    #/usr/bin/printenv | grep -v '^_=' | sed -e "s/\([^=]\)=/\1='/" -e "s/$/'/g" > $ENVLAST
    /usr/bin/env | cut -d'=' -f 1 | egrep -v '^_$|^\s|^	|^$' | while read var; do echo "$var='`/usr/bin/printenv $var`'"; done > $ENVLAST
    if [ -s $ENVSTART ] ; then
        echo "ENVLAST=\"$ENVLAST\"" >> $ENVSTART
        msgOut INFO "Resetting the environment from $ENVSTART"
        source $ENVSTART
    fi

    # Start the validation
    SWPHYS=${RELLOC}
    SWLOG=${SWLOC}
    if [ "${SWPATH}" != "" ] ; then
        SWPHYS="$SWPATH"
        SWLOG="$SWPATH"
    fi
    cd ${TOPDIR}
    TESTDIR=${TOPDIR}/atlas_test.$$
    mkdir "$TESTDIR"
    cd "$TESTDIR"
    if [ "$VALEXE" != "" ] ; then
        # Run an external validation script
        msgOut INFO "Setting up the release from ${SWLOG}"
        source ${SWLOG}/setup.sh
        msgOut INFO "Executing the external validation exe $TOPDIR/$VALEXE"
        chmod +x $TOPDIR/`echo $VALEXE | awk '{print $1}'`
        $TOPDIR/$VALEXE
        validrc=$?
    else
        if [ "${PRJTYPE}" == "ext" ] ; then
            # Let's run a generic setup and print the environment + some other commands
            msgOut INFO "Setting up the release from ${SWLOG}"
            source ${SWLOG}/setup.sh
            validrc=$?
            msgOut INFO "Printing the environment"
            msgOut INFO "`printenv`"
            [ "`which lcg-cp 2>/dev/null`"  != "" ] && msgOut INFO "lcg-cp:  `which lcg-cp`"
            [ "`which lcg-cr 2>/dev/null`"  != "" ] && msgOut INFO "lcg-cr:  `which lcg-cr`"
            [ "`which lcg-del 2>/dev/null`" != "" ] && msgOut INFO "lcg-del: `which lcg-del`"
        else
            # Let's run KitValidation
            if [ "${PRJNAME}" == "AtlasRelease" -o "${PRJNAME}" == "release" ] ; then
                KVBUILD_OPTS=""
            else
                RELSERIAL="`echo $RELEASE | cut -d "." -f 1-3 | awk -F. '{printf "%d",$1; for(i=2;i<=NF;i++) printf "%03d", $i;}'`"
                if [ "${PRJNAME}" == "AtlasOffline" -a $RELSERIAL -lt 13000030 -a $RELSERIAL -gt 0 ] ; then
                    KVBUILD_OPTS="--project AtlasProduction"
                else
                    KVBUILD_OPTS="--project ${PRJNAME}"
                fi
            fi
            [ "$T_POST" == "yes" ] && msgOut INFO "KV posting enabled"
            [ "$KVPOSTTAG" != "" ] && msgOut INFO "Using GKV tag $KVPOSTTAG"
            [ "${PRJTYPE}" == "bugfix" -o "${PRJTYPE}" == "dev" -o "${PRJTYPE}" == "p1nightly" ] && KVRELTYPE=":${PRJTYPE}" || KVRELTYPE=""
            [ "${PRJTYPE}" == "p1patch" ] && KVRELTYPE=":p1" || KVRELTYPE=""
            [ "${PRJTYPE}" == "eventview" ] && KVRELTYPE=":ev" || KVRELTYPE=""
            KVRELBASE="`echo $RELEASE | cut -d "." -f 1-3`"
            if [ "$DEBUG" == "yes" ] ; then
                msgOut DEBUG "PATH=${PATH}"
                msgOut DEBUG "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
                msgOut DEBUG "PYTHONPATH=${PYTHONPATH}"
            fi
            msgOut INFO "Starting validation for release $RELEASE"
            msgOut INFO "Executing pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVRELBASE}/KitValidation"
            pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVRELBASE}/KitValidation
            msgOut INFO "Executing pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVRELBASE}/KitValidationPatches"
            pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVRELBASE}/KitValidationPatches
            [ $? -eq 0 ] && source setup.sh
            if [ "$KVBUILD_OPTS" != "" ] ; then
                if [ "${PRJTYPE}" == "p1nightly" ] ; then
                    msgOut INFO "Setting up the point1 nightly release from $PWD"
                    msgOut INFO "source ${SWLOC}/cmtsite/setup.sh -tag=${PRJNAME},${RELEASE},${PRJOPT},runtime"
                    source ${SWLOC}/cmtsite/setup.sh -tag=${PRJNAME},${RELEASE},${PRJOPT},runtime
                elif [ "${PRJTYPE}" == "patch" -o "${PRJTYPE}" == "p1patch" -o "${PRJTYPE}" == "eventview" ] ; then
                    msgOut INFO "Setting up the release from $PWD"
                    msgOut INFO "source ${SWLOC}/cmtsite/setup.sh -tag=${REQPRJNAME},${KVRELBASE},${PRJOPT},runtime"
                    source ${SWLOC}/cmtsite/setup.sh -tag=${REQPRJNAME},${KVRELBASE},${PRJOPT},runtime
                else
                    msgOut INFO "Setting up the release from $PWD"
                    msgOut INFO "source ${SWLOC}/cmtsite/setup.sh -tag=${PRJNAME},${RELEASE},${PRJOPT}"
                    source ${SWLOC}/cmtsite/setup.sh -tag=${PRJNAME},${RELEASE},${PRJOPT}
                fi
                if [ "${PRJTYPE}" == "patch" -o "${PRJTYPE}" == "p1patch" ] ; then
                    msgOut INFO "Using patch release $RELEASE from $PWD"
                    unset CMTPATH
                    cd ${SITEROOT}/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime/cmt
                    source setup.sh
                    validrc=$?
                    if [ $validrc -eq 0 ] ; then
                        msgOut INFO "Patch release ${RELEASE} setup complete"
                        msgOut INFO "CMTPATH=${CMTPATH}"
                    else
                        msgOut ERROR "Cannot setup patch release ${RELEASE}"
                    fi
                    cd -
                elif [ "${PRJTYPE}" == "eventview" ] ; then
                    msgOut INFO "Using EventView version $RELEASE from $PWD"
                    setupDev "-tag=${REQPRJNAME},${KVRELBASE},groupArea,runtime"
                    #validrc=$?
                    validrc=1
                else
                    msgOut INFO "Using plain release $RELEASE from $PWD"
                    msgOut INFO "Executing pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVRELBASE}/KitValidationPyJTPatches"
                    pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVRELBASE}/KitValidationPyJTPatches
                    msgOut INFO "Setting up the main release runtime: source ${SWLOC}/cmtsite/setup.sh -tag=${PRJNAME},${RELEASE},${PRJOPT},runtime"
                    source ${SWLOC}/cmtsite/setup.sh -tag=${PRJNAME},${RELEASE},${PRJOPT},runtime
                    if [ -d $PWD/AtlasProduction/*/AtlasProductionRunTime/cmt ] ; then
                        EPREL="`find $PWD/AtlasProduction -maxdepth 1 -exec basename {} \; | tail -n 1`"
                        msgOut INFO "Setting up the embedded patch ${EPREL} runtime environment"
                        unset CMTPATH
                        cd $PWD/AtlasProduction/$EPREL/AtlasProductionRunTime/cmt
                        source setup.sh
                        cd -
                    fi
                fi
            fi
            if [ $validrc -eq 0 ] ; then
                # Override the DB release if needed
                if [ "$DBREL" != "" ] ; then
                    export DBRELEASE_OVERRIDE=$DBREL
                    msgOut INFO "Using DBRelease $DBRELEASE_OVERRIDE"
                fi

                # Start the test threads
                for kvthr in `seq 1 $TESTTHR`; do
                    TTDIR="$TESTDIR/KV.thr.$kvthr"
                    mkdir -p $TTDIR; cd $TTDIR
                    \find $TESTDIR/ -maxdepth 1 -type d -name "KitValidation" -exec cp -a {} . \;
                    \find $TESTDIR/ -maxdepth 1 -type d -name "JobTransforms" -exec cp -a {} . \;
                    \find $TESTDIR/ -maxdepth 1 -type d -name "Atlas*" -exec ln -s {} . \;
                    KVHOME=`\find $PWD/KitValidation/ -type d -name share`
                    [ "$KVDISABLE" != "" ] && KVDISABLE_OPTS=" --disable $KVDISABLE"
                    if [ "$KVD" != "" ] ; then
                        if [ "$KVDISABLE_OPTS" != "" ] ; then
                            KVDISABLE_OPTS="$KVDISABLE_OPTS,$KVD"
                        else
                            KVDISABLE_OPTS=" --disable $KVD"
                        fi
                    fi
                    KVVER="`${KVHOME}/KitValidation -V | grep version | awk '{print $4'} | awk -F. '{printf "%d",$1; for(i=2;i<=NF;i++) printf "%03d", $i;}'`"
                    if [ $KVVER -ge 1009015 -a "$REQPRJNAME" != "" ] ; then
                        # This switch is supported only since release 1.9.15 of KV
                        KVADDSEARCH=" --search $REQPRJNAME"
                    else
                        [ "$REQPRJNAME" != "" ] && msgOut WARNING "Ignoring KV release base search for KV-$KVVER"
                    fi
                    if [ $KVVER -ge 1009016 -a "$KVPOSTTAG" != "" ] ; then
                        # This switch is supported only since release 1.9.16 of KV
                        KVPOSTTAG_OPTS=" --kvpost-tag ${KVPOSTTAG}"
                    else
                        [ "$KVPOSTTAG" != "" ] && msgOut WARNING "Ignoring KV user tags for KV-$KVVER"
                    fi
                    if [ $KVVER -ge 1009017 -a "$KVCONFURL" != "" ] ; then
                        # This switch is supported only since release 1.9.17 of KV
                        KVCONFURL_OPTS=" --test-config \"${KVCONFURL}\""
                    else
                        [ "$KVCONFURL" != "" ] && msgOut WARNING "Ignoring KV custom configuration XML for KV-$KVVER"
                    fi
                    if [ $KVVER -ge 1009016 -a "$KVE" != "" ] ; then
                        # This switch is supported only since release 1.9.16 of KV
                        KVENABLE_OPTS=" --enable ${KVE}"
                    else
                        [ "$KVE" != "" ] && msgOut WARNING "Test enabling not supported in KV-$KVVER"
                    fi
                    msgOut INFO "Starting KV (thread #${kvthr}/${TESTTHR})..."
                    msgOut INFO "${KVHOME}/KitValidation -r ${RELEASE}${KVRELTYPE} -p ${SWLOC} -gkvn --bw -t ${PWD} ${KVBUILD_OPTS}${KVDISABLE_OPTS}${KVADDSEARCH}${KVPOSTTAG_OPTS}${KVCONFURL_OPTS}${KVENABLE_OPTS}"
                    if [ "$DEBUG" == "yes" ] ; then
                        msgOut DEBUG "PATH=${PATH}"
                        msgOut DEBUG "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
                        msgOut DEBUG "PYTHONPATH=${PYTHONPATH}"
                    fi
                    (${KVHOME}/KitValidation -r ${RELEASE}${KVRELTYPE} -p ${SWLOC} -gkvn --bw \
                     -t ${PWD} ${KVBUILD_OPTS}${KVDISABLE_OPTS}${KVADDSEARCH}${KVPOSTTAG_OPTS}${KVCONFURL_OPTS}${KVENABLE_OPTS}; \
                     echo $? > ${TTDIR}.rc) &
                done
                # Wait for the threads to finish
                msgOut INFO "Waiting for ${TESTTHR} thread(s) to finish"
                wait
                # Calculate the global return code
                for kvthr in `seq 1 $TESTTHR`; do
                    TTDIR="$TESTDIR/KV.thr.$kvthr"
                    let validrc=$validrc+`cat ${TTDIR}.rc`
                done
            fi
        fi
    fi

    # Print out the test result
    if [ $validrc -ne 0 ] ; then
        msgOut ERROR "Test FAILED [rc=$validrc]"
    else
        msgOut INFO "Test OK [rc=$validrc]"
    fi

    # Clean up
    cd ${TOPDIR}
    rm -fr "$TESTDIR"

    # Reset the environment
    if [ -s $ENVLAST ] ; then
        msgOut INFO "Reverting to the environment from $ENVLAST"
        source $ENVLAST
        rm -f $ENVLAST
    fi

    # End of the function
    return $validrc
}


findRelease() {
    RELDEFAULTLOC="${1}"
    DIRFOUND="`find ${RELDEFAULTLOC} -name "AtlasRelease" -o -name "${PRJNAME}Release" -type d 2>/dev/null | grep ".*[(dist),(${PRJNAME})]/${RELEASE}/" | tail -n 1`"
    if [ "$DIRFOUND" == "" ] ; then
        STARTDIR="`echo ${RELDEFAULTLOC} | xargs dirname | xargs dirname`"
        #[ "$VO_ATLAS_SW_DIR" != "" ] && STARTDIR=$VO_ATLAS_SW_DIR
        echo "The default directory $RELDEFAULTLOC does not contain release $RELEASE. Searching release $RELEASE performing a FULL DISK SCAN starting from $STARTDIR" > /dev/stderr
        DIRFOUND="`find $STARTDIR -name "AtlasRelease" -o -name "${PRJNAME}Release" -type d 2>/dev/null | grep ".*[(dist),(${PRJNAME})]/${RELEASE}/" | tail -n 1`"
    fi
    if [ "$DIRFOUND" != "" ] ; then
        echo "Release found in $DIRFOUND" > /dev/stderr
        DIRFOUND="`dirname $DIRFOUND | xargs dirname | xargs dirname`"
        echo "Using installation dir $DIRFOUND" > /dev/stderr
    fi
    echo $DIRFOUND
}


remove() {
    let removerc=0
    msgOut INFO "Removal of ${PRJNAME} ${RELEASE} started at `date`"

    # Setup the release and check the physical install path
    msgOut INFO "Setting up ${PRJNAME} ${RELEASE} from ${SWLOC}"
    if [ -s ${SWLOC}/setup.sh ] ; then
        source ${SWLOC}/setup.sh
        let setuprc=$?
        msgOut INFO "SITEROOT is ${SITEROOT}"
        if [ $setuprc -eq 0 ] ; then
            if [ -s "${SITEROOT}/setup.sh" -a "${RELLOC}" != "${SITEROOT}" -a "${SWLOC}" != "${SITEROOT}" ] ; then
                if [ "$PRJTYPE" != "ext" ] ; then
                    #msgOut INFO "Resetting physical installation location from ${RELLOC} to ${SITEROOT}"
                    #RELLOC=${SITEROOT}
                    msgOut INFO "The logical installation dir point to a different version of ${PRJNAME}. I will not delete ${SWLOC}."
                    SWLOC="none"
                else
                    BASEDIR="`dirname ${SWLOC}`"
                    NUMDIRS="`\ls -d ${BASEDIR}/* | grep -v -E "${SWLOC}|${RELLOC}" | wc -l`"
                    if [ ${NUMDIRS} -gt 0 ] ; then
                        msgOut INFO "The logical installation dir point to a different version of ${PRJNAME}. I will not delete ${SWLOC}."
                        SWLOC="none"
                    fi
                fi
            fi
        fi
    fi

    for RELLOCFOUND in `\ls -d ${RELLOC} ${RELLOC}.r* 2>/dev/null` ; do
        LOCKFILE=${RELLOCFOUND}/atlas-install.lock
        if [ "$PRJTYPE" != "ext" ] ; then
            # Detect the physical installation area
            #msgOut INFO "Detecting physical location of $PRJNAME $RELEASE. Please wait, this could take some time."
            #RELLOCFOUND="`findRelease $RELLOC`"
            #if [ "$RELLOCFOUND" == "" ] ; then
            #    msgOut INFO "Release not detected in $RELLOC or in other areas (using FULL DISK SCAN). Trying anyway."
            #    RELLOCFOUND="$RELLOC"
            #else
            #    msgOut INFO "Release $RELEASE found in $RELLOCFOUND"
            #fi
            msgOut INFO "Trying with release $RELEASE in $RELLOCFOUND"

            # Check if any patch is installed
            if [ "$RELLOCFOUND" != "" -a "$PRJTYPE" != "patch" -a "${PRJTYPE}" != "p1patch" -a "${PRJTYPE}" != "eventview" ] ; then
                msgOut INFO "Detecting patches for $RELEASE"
                cd "${RELLOC}"
                PATCHPATTERN="Atlas.*_`echo $RELEASE | sed 's#\.#_#g'`_[[:digit:]+].*"
                INSTALLED_PATCHES="`pacman -lc -d none | grep "$PATCHPATTERN" | cut -d "_" -f 2-5 | sed 's#_#\.#g' | sort | uniq`"
                if [ "$INSTALLED_PATCHES" != "" ] ; then
                    msgOut ERROR "The following patches to ${RELEASE} are installed"
                    msgOut ERROR "`echo ${INSTALLED_PATCHES} | sed 's# #,#g'`"
                    msgOut ERROR "Please remove all the patches before removing release $RELEASE"
                    return 150
                else
                    msgOut INFO "No installed patches found for release $RELEASE"
                fi
            fi
        #else
        #    RELLOCFOUND="${RELLOC}"
        fi

        # Wait for previous installation process completion
        if [ -f ${LOCKFILE} ] ; then
            msgOut WARNING "Another installation process is currently active. Now waiting..."
            waittime=0
            while `test -f ${LOCKFILE}`; do
                sleep 1s
                let waittime=$waittime+1
                if [ $waittime -gt 3600 ] ; then
                    msgOut WARNING "Timeout [3600 s]"
                    msgOut WARNING "Removing stale installation lock"
                    rm -f ${LOCKFILE}
                fi
            done
        fi
        if [ -d `dirname ${LOCKFILE}` ] ; then
            msgOut INFO "Locking the installation area"
            echo "$RELEASE installation lock" > ${LOCKFILE}
            case `whoami` in
                *[0-9])
                    msgOut INFO "This site is configured for SGM pool accounts. Changing group permissions to ${LOCKFILE}"
                    chmod -R g+w ${LOCKFILE} 2>/dev/null
                    [ $? -ne 0 ] && msgOut ERROR "Cannot change group write permissions to ${LOCKFILE}"
                ;;
            esac
        else
            msgOut ERROR "Cannot lock the installation area because the directory does not exists."
        fi

        # Remove the physical installation
        if [ -d ${RELLOCFOUND} ] ; then
            RELLOCBEFORE="`du -sk ${RELLOCFOUND} 2>/dev/null | awk '{print $1}'`"
            [ "$RELLOCBEFORE" == "" ] && RELLOCBEFORE=0
            if [ $RELLOCBEFORE -lt $MININSTALLSIZE ] ; then
                msgOut INFO "Physical installation area size is ${RELLOCBEFORE} kB. Removing the directory."
                rm -fr ${RELLOCFOUND}
                let removerc=$removerc+$?
            else
                cd "${RELLOCFOUND}"
                if [ "$PACKOPT" == "all" ] ; then
                    msgOut INFO "Removing gcc from $PWD"
                    pacman -remove ${RELEASE}/${GCC}
                fi
                if [ "$DBREL" != "" ] ; then
                    msgOut INFO "Removing DBRelease $DBREL from $PWD"
                    pacman -remove ${DBRELPKG}
                    let removerc=$removerc+$?
                    [ $removerc -ne 0 ] && msgOut WARNING "Error during DBRelease removal"
                fi
                msgOut INFO "Removing physical installation of ${ATLASRELEASE} from $PWD"
                pacman -remove ${ATLASRELEASE}
                let removerc=$removerc+$?
                [ $removerc -ne 0 ] && msgOut ERROR "Error while removing ${ATLASRELEASE}"
                if [ $removerc -eq 0 -a "$EXTRAPKG" != "" ] ; then
                    msgOut INFO "Removing physical installation of ${EXTRAPKG} from $PWD"
                    pacman -remove ${EXTRAPKG}
                    if [ $? -ne 0 ] ; then
                        msgOut WARNING "Cannot remove ${EXTRAPKG}"
                        msgOut ERROR "`pacman -last`"
                    fi
                fi
                if [ $removerc -ne 0 ] ; then
                    msgOut ERROR "`pacman -last`"
                else
                    pacman -clear-snapshots

                    # Cleaning up the directories
                    [ -d dist/${RELEASE} ] && rm -fr dist/${RELEASE}
                    cd "${TOPDIR}"
                    RELLOCSIZE="`du -sk ${RELLOCFOUND} 2>/dev/null | awk '{print $1}'`"
                    [ "$RELLOCSIZE" == "" ] && RELLOCSIZE=-1
                    if [ ${RELLOCSIZE} -lt $MININSTALLSIZE ] ; then
                        if [ ${RELLOCSIZE} -lt 0 ] ; then
                            msgOut INFO "Physical installation area does not exists anymore."
                        else
                            msgOut INFO "Physical installation area size is ${RELLOCSIZE} kB. Removing the directory."
                            rm -fr ${RELLOCFOUND}
                            let removerc=$removerc+$?
                        fi
                    else
                        msgOut INFO "Physical installation area size is ${RELLOCSIZE} kB. The directory is not empty."
                    fi 
                fi
            fi
            RELLOCAFTER="`du -sk ${RELLOCFOUND} 2>/dev/null | awk '{print $1}'`"
            [ "$RELLOCAFTER" == "" ] && RELLOCAFTER=0
            msgOut INFO "Disk space saved: `echo $((${RELLOCBEFORE}-${RELLOCAFTER})) | awk '{printf "%7.1f", $1/1024}'` MB"
        else
            msgOut INFO "Physical installation area ($RELLOCFOUND) does not exists and no candidates have been found."
        fi
    done

    # Remove the logical installation, unless we're processing patches
    cd "${TOPDIR}"
    if [ "$PRJTYPE" != "patch" -a "${PRJTYPE}" != "p1patch" -a "${PRJTYPE}" != "eventview" -a "${SWLOC}" != "none" ] ; then
        if [ -d ${SWLOC} ] ; then
            msgOut INFO "Removing logical installation from ${SWLOC}"
            SWLOCBEFORE="`du -sk ${SWLOC} 2>/dev/null | awk '{print $1}'`"
            [ "$SWLOCBEFORE" == "" ] && SWLOCBEFORE=0
            rm -fr "${SWLOC}"
            SWLOCAFTER="`du -sk ${SWLOC} 2>/dev/null | awk '{print $1}'`"
            [ "$SWLOCAFTER" == "" ] && SWLOCAFTER=0
            msgOut INFO "Disk space saved: `echo $((${SWLOCBEFORE}-${SWLOCAFTER})) | awk '{printf "%7.1f", $1/1024}'` MB"
        else
            msgOut INFO "Logical installation area ($SWLOC) does not exists."
        fi
    fi

    # List the software area contents
    SWLOCPATH="`dirname ${SWLOC}`" 
    RELLOCPATH="`dirname ${RELLOC}`" 
    if [ "${PRJTYPE}" != "patch" -a "${PRJTYPE}" != "p1patch" -a "${PRJTYPE}" != "eventview" -a "$SWLOC" != "none" ] ; then
        msgOut INFO "Showing contents of the logical installation path (${SWLOCPATH})"
        msgOut INFO "`\ls ${SWLOCPATH}`"
    fi
    msgOut INFO "Showing contents of the physical installation path (${RELLOCPATH})"
    msgOut INFO "`\ls ${RELLOCPATH}`"
    msgOut INFO "Unlocking the installation area"
    rm -f ${LOCKFILE}
    return $removerc
}


addTag() {
    # Reset the environment
    ENVLAST="/tmp/sw-mgr-envlast.tmp.$$"
    #/usr/bin/printenv | grep -v '^_=' | sed -e "s/\([^=]\)=/\1='/" -e "s/$/'/g" > $ENVLAST
    /usr/bin/env | cut -d'=' -f 1 | egrep -v '^_$|^\s|^	|^$' | while read var; do echo "$var='`/usr/bin/printenv $var`'"; done > $ENVLAST
    if [ -s $ENVSTART ] ; then
        echo "ENVLAST=\"$ENVLAST\"" >> $ENVSTART
        msgOut INFO "Resetting the environment from $ENVSTART"
        source $ENVSTART
    fi

    # Search for the tagging utility
    TAG_UTILITY="`which lcg-tags 2> /dev/null`"
    if [ "$TAG_UTILITY" == "" ] ; then
        msgOut ERROR "Tagging utility (lcg-tags) not present."
        return 60
    else
        msgOut INFO "Using $TAG_UTILITY"
    fi
    let addtagrc=0
    if [ "$TAGHOST" == "" ] ; then
        msgOut ERROR "No host to manage tags"
        let addtagrc=$addtagrc+1
    fi
    if [ "$TAGVO" == "" ] ; then
        msgOut ERROR "No VO to manage tags"
        let addtagrc=$addtagrc+1
    fi
    if [ $addtagrc -eq 0 ] ; then
        msgOut INFO "Listing current tags"
        msgOut INFO "`$TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list`"
        msgOut INFO "Adding tags $TAGNAME"
        $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --add --tags $TAGNAME
        let addtagrc=$addtagrc+$?

        # Extra tag
        if [ $addtagrc -eq 0 ] ; then
            if [ "$EXTRATAG" != "" ] ; then
                TAGDEL="`$TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list | grep ${EXTRATAG}$ | tail -n 1`"
                if [ "$TAGDEL" != "" ] ; then
                    msgOut INFO "Removing tag $TAGDEL"
                    $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --remove --tags $TAGDEL
                    let addtagrc=$addtagrc+$?
                fi
                if [ $addtagrc -eq 0 ] ; then
                    msgOut INFO "Adding tag ${TAGNAME}-${EXTRATAG}"
                    $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --add --tags ${TAGNAME}-${EXTRATAG}
                    let addtagrc=$addtagrc+$?
                else
                    msgOut ERROR "Cannot remove tag $TAGDEL"
                fi
            fi
        fi
        msgOut INFO "Listing new tags"
        msgOut INFO "`$TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list`"
        $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list | grep -q ${TAGNAME}
        if [ $? -ne 0 ] ; then
            msgOut ERROR "The tagging utility reports no error but the tag was not added"
            let addtagrc=$addtagrc+1
        fi
        if [ "$DUMPTAGS" != "" ] ; then
            msgOut INFO "Dumping tags into $DUMPTAGS"
            $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list > $DUMPTAGS
            if [ $? -ne 0 ] ; then
                msgOut ERROR "Cannot dump tags to $DUMPTAGS"
                let addtagrc=$addtagrc+1
            fi
        fi
    fi

    # Reset the environment
    if [ -s $ENVLAST ] ; then
        msgOut INFO "Reverting to the environment from $ENVLAST"
        source $ENVLAST
        rm -f $ENVLAST
    fi

    # Return from this fuction
    return $addtagrc
}


removeTag() {
    # Reset the environment
    ENVLAST="/tmp/sw-mgr-envlast.tmp.$$"
    #/usr/bin/printenv | grep -v '^_=' | sed -e "s/\([^=]\)=/\1='/" -e "s/$/'/g" > $ENVLAST
    /usr/bin/env | cut -d'=' -f 1 | egrep -v '^_$|^\s|^	|^$' | while read var; do echo "$var='`/usr/bin/printenv $var`'"; done > $ENVLAST
    if [ -s $ENVSTART ] ; then
        echo "ENVLAST=\"$ENVLAST\"" >> $ENVSTART
        msgOut INFO "Resetting the environment from $ENVSTART"
        source $ENVSTART
    fi

    # Search for the tagging utility
    TAG_UTILITY="`which lcg-tags 2> /dev/null`"
    if [ "$TAG_UTILITY" == "" ] ; then
        msgOut ERROR "Tagging utility (lcg-tags) not present."
        return 60
    fi
    let removetagrc=0
    if [ "$TAGHOST" == "" ] ; then
        msgOut ERROR "No host to manage tags"
        let removetagrc=$removetagrc+1
    fi
    if [ "$TAGVO" == "" ] ; then
        msgOut ERROR "No VO to manage tags"
        let removetagrc=$removetagrc+1
    fi
    if [ $removetagrc -eq 0 ] ; then
        msgOut INFO "Removing tags $TAGNAME"
        $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --remove --tags $TAGNAME
        let removetagrc=$removetagrc+$?

        # Extra tag
        if [ "$EXTRATAG" != "" ] ; then
            msgOut INFO "Removing tag ${TAGNAME}-${EXTRATAG}"
            $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --remove --tags ${TAGNAME}-${EXTRATAG}
            let removetagrc=$removetagrc+$?
        fi
        msgOut INFO "Listing current tags"
        msgOut INFO "`$TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list`"
        if [ "$DUMPTAGS" != "" ] ; then
            msgOut INFO "Dumping tags into $DUMPTAGS"
            $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list > $DUMPTAGS
            if [ $? -ne 0 ] ; then
                msgOut ERROR "Cannot dump tags to $DUMPTAGS"
                let removetagrc=$removetagrc+1
            fi
        fi
    fi

    # Reset the environment
    if [ -s $ENVLAST ] ; then
        msgOut INFO "Reverting to the environment from $ENVLAST"
        source $ENVLAST
        rm -f $ENVLAST
    fi

    # Return from this fuction
    return $removetagrc
}


# Query the cached releases
query() {
    let queryrc=0
    mode="${1}"
    if [ "$mode" != "-quiet" ] ; then
        printf "List of releases available locally:\n"
        printf "===========================================================================\n"
        printf "| %12s | %10s | %20s | %20s |\n" "Type" "Version" "Architecture" "Date/Time"
        printf "===========================================================================\n"
    fi
    ATLVER_1=""
    ATLVER_2=""
    TMPFILE="/tmp/tmp.query.$$"
    for snap in `\ls -d $SNAPDIR/*.snap* 2>/dev/null` ; do
        snapname="`echo $snap | awk -F '-' '{print $2"-"$(NF-3)"-"$(NF-1)}' | sed 's/\.snap//g'`"
        ATLTYPE="`echo $snapname | cut -d '-' -f 1`"
        ATLVER="`echo $snapname | cut -d '-' -f 2`"
        ATLARCH="`echo $snapname | cut -d '-' -f 3`"
        ATLDT="`stat -c %y $snap 2>&1 | cut -d '.' -f 1`"
        if [ "$mode" != "-quiet" ] ; then
            printf "| %12s | %10s | %20s | %20s |\n" "$ATLTYPE" "$ATLVER" "$ATLARCH" "$ATLDT" >> $TMPFILE
        fi
        [ "$ATLVER_1" == "" ] && ATLVER_1="$ATLVER"
        ATLVER_2="$ATLVER"
    done
    cat $TMPFILE 2> /dev/null | sort -n -k 2
    rm -f $TMPFILE
    if [ "$mode" != "-quiet" ] ; then
        printf "===========================================================================\n"
    else
        if [ "${ATLVER_1}" != "${ATLVER_2}" ] ; then
            echo "${ATLVER_1}_${ATLVER_2}"
        else
            echo "${ATLVER_1}"
        fi
    fi
    return $queryrc
}


writeDVD() {
    let writedvdrc=0
    image="${1}"
    CDRECORD="cdrecord"
    CDSCAN="$CDRECORD -scanbus"
    CDWRITE="$CDRECORD -v -eject -dao"
    TMPSCAN=/tmp/tmp.scan.$$
    $CDSCAN 2>&1 \
            | awk '/.,.,..*CD-ROM/ {indx+=1; print "["indx"] "$0}' > $TMPSCAN
    cat $TMPSCAN
    echo -n "Please choose a device to write: "
    read dev
    DEV_ADDR="`grep \"^\[$dev\]\" $TMPSCAN | cut -f 2`"
    echo "Device $DEV_ADDR selected for writing..."
    rm -fr $TMPSCAN
    $CDWRITE dev=ATA:${DEV_ADDR} "${image}"
    let writedvdrc=$writedvdrc+$?
    return $writedvdrc
}


mkiso() {
    let mkisorc=0
    MKISOFS="mkisofs"
    image="${1}"
    volume="${2}"
    preparer="${3}"
    inpath="${4}"
    TMPDIR=/tmp/tmp.mkiso.$$
    mkdir "$TMPDIR"
    cd "$TMPDIR"
    ln -sf "$inpath" .
    cd "$TOPDIR"
    $MKISOFS -f -J -r -o "$image" -V "$volume" -p "$preparer" -m "*.gz" $TMPDIR
    rm -fr $TMPDIR
    echo "Do you want to write a DVD [Y/n] ?"
    read dowrite
    if [ "$dowrite" == "" -o "$dowrite" == "Y" -o "$dowrite" == "y" ] ; then
        writeDVD $image
    else
        echo "The DVD image $image has been created successfully"
    fi
    let mkisorc=$mkisorc+$?
    return $mkisorc
}

cleanup() {
    let cleanrc=0
    LOCKFILE=${RELLOC}/atlas-install.lock
    if [ -f ${SWLOC}/setup.sh ] ; then
      source ${SWLOC}/setup.sh
      if [ -f ${SITEROOT}/setup.sh -a "${RELLOC}" != "${SITEROOT}" -a "${SWLOC}" != ${SITEROOT} -a $? -eq 0 ] ; then
        #msgOut INFO "Resetting physical installation location from ${RELLOC} to ${SITEROOT}"
        #RELLOC=${SITEROOT}
        msgOut INFO "The logical installation points to a different SITEROOT (expected: ${RELLOC}, actual: ${SITEROOT}). I will not delete ${SWLOC}"
        SWLOC="none"
      fi
    fi

    # Wait for previous installation process completion
    if [ -f ${LOCKFILE} ] ; then
        msgOut WARNING "Another installation process is currently active. Now waiting..."
        waittime=0
        while `test -f ${LOCKFILE}`; do
            sleep 1s
            let waittime=$waittime+1
            if [ $waittime -gt 3600 ] ; then
                msgOut WARNING "Timeout [3600 s]"
                msgOut WARNING "Removing stale installation lock"
                rm -f ${LOCKFILE}
            fi
        done
    fi
    msgOut INFO "Locking the installation area"
    echo "$RELEASE installation lock" > ${LOCKFILE}
    case `whoami` in
        *[0-9])
            msgOut INFO "This site is configured for SGM pool accounts. Changing group permissions to ${LOCKFILE}"
            chmod -R g+w ${LOCKFILE} 2>/dev/null
            [ $? -ne 0 ] && msgOut ERROR "Cannot change group write permissions to ${LOCKFILE}"
        ;;
    esac

    if [ -d ${SWLOC} ] ; then
      msgOut INFO "Removing $SWLOC"
      SWLOCBEFORE="`du -sk ${SWLOC} 2>/dev/null | awk '{print $1}'`"
      [ "$SWLOCBEFORE" == "" ] && SWLOCBEFORE=0
      rm -fr $SWLOC
      let swclean=$?
      let cleanrc=$cleanrc+$swclean
      [ $swclean -ne 0 ] && msgOut ERROR "An error occurred while removing ${SWLOC}"
      SWLOCAFTER="`du -sk ${SWLOC} 2>/dev/null | awk '{print $1}'`"
      [ "$SWLOCAFTER" == "" ] && SWLOCAFTER=0
      msgOut INFO "Disk space saved: `echo $((${SWLOCBEFORE}-${SWLOCAFTER})) | awk '{printf "%7.1f", $1/1024}'` MB"
    else
      msgOut INFO "No directory ${SWLOC} found"
    fi

    RELLOCS="`\ls -d ${RELLOC} ${RELLOC}.r* 2>/dev/null`"
    for RLOC in ${RELLOCS} ; do
      msgOut INFO "Removing $RLOC"
      RELLOCBEFORE="`du -sk ${RLOC} 2>/dev/null | awk '{print $1}'`"
      [ "$RELLOCBEFORE" == "" ] && RELLOCBEFORE=0
      rm -fr $RLOC
      let relclean=$?
      let cleanrc=$cleanrc+$relclean
      [ $relclean -ne 0 ] && msgOut ERROR "An error occurred while removing ${RLOC}"
      RELLOCAFTER="`du -sk ${RLOC} 2>/dev/null | awk '{print $1}'`"
      [ "$RELLOCAFTER" == "" ] && RELLOCAFTER=0
      msgOut INFO "Disk space saved: `echo $((${RELLOCBEFORE}-${RELLOCAFTER})) | awk '{printf "%7.1f", $1/1024}'` MB"
    done
    if [ "$RELLOCS" == "" ] ; then
      msgOut INFO "No directory ${RELLOC} or ${RELLOC}.r* found"
    fi

    if [ $cleanrc -ne 0 ] ; then
        msgOut ERROR "Cannot remove the installation directories"
    else
        msgOut INFO "Cleanup OK"
    fi

    # List the software area contents
    SWLOCPATH="`dirname ${SWLOC}`" 
    RELLOCPATH="`dirname ${RELLOC}`" 
    msgOut INFO "Showing contents of the logical installation path (${SWLOCPATH})"
    msgOut INFO "`\ls ${SWLOCPATH}`"
    msgOut INFO "Showing contents of the physical installation path (${RELLOCPATH})"
    msgOut INFO "`\ls ${RELLOCPATH}`"

    # Unlock the installation area
    msgOut INFO "Unlocking the installation area"
    rm -f ${LOCKFILE}

    return $cleanrc
}

setupPacman() {
    let setuprc=0
    # Use ${INSTALLER_HOME} to store pacman
    cd ${INSTALLER_HOME}
    # Download/find and install pacman, if needed
    if [ ! -d ${PACMAN_DIR} ] ; then
        msgOut WARNING "Pacman not found in `dirname ${PACMAN_DIR}`"
        if [ ! -s ${PACMAN_TAR} ] ; then
            wget ${PACMAN_URL}/`basename ${PACMAN_TAR}`
            let setuprc=$setuprc+$?
            if [ ! -s ${PACMAN_TAR} ] ; then
                msgOut ERROR "Cannot get pacman ${PACMAN_VER} from ${PACMAN_URL}"
                return 50
            fi
        fi
        msgOut INFO "Installing pacman ${PACMAN_VER}"
        tar xfz ${PACMAN_TAR}
        let setuprc=$setuprc+$?
        PACMAN_DIR="$PWD/`basename ${PACMAN_DIR}`"
        cd "${PACMAN_DIR}"
        [ "${PACMAN_PATCH}" != "" -a -s "${PACMAN_PATCH}" ] && \
             patch -p1 < ${PACMAN_PATCH}
        cd "${TOPDIR}"
    fi

    # Setup pacman
    cd "${PACMAN_DIR}"
    source $PWD/setup.sh
    let setuprc=$setuprc+$?
    if [ $setuprc -eq 0 ] ; then
        msgOut INFO "pacman ${PACMAN_VER} installed and set up correctly from ${PACMAN_DIR}."
        if [ "`which pacman 2>/dev/null`" == "" ] ; then
            msgOut ERROR "Cannot find the 'pacman' executable"
            msgOut INFO  "$PWD"
            msgOut INFO  "$PACMAN_LOCATION"
            setuprc=10
        fi
    else
        msgOut ERROR "Unable to setup pacman ${PACMAN_VER}."
    fi
    return $setuprc
}

# MAIN program
msgOut INFO "$VERSION starting"

# Deafults
MKDVD="no"
PACKOPT="all"
PRJNAME="release"
PRJTYPE="release"
PRJOPT="opt"
PACMAN_VER="3.18.5"
TEMPCACHE="no"
TAGACTION="none"
REGISTER="no"
RELVER="1"
USEGRID="no"
GRIDREPLICA="no"
TAGVO="atlas"
MINDF="6000000:20000:3000000"
MININSTALLSIZE=100000
REQSHAREDFS="no"
XMLFILE=""
T_POST="no"
REINSTALL="no"
UPDATE="no"
EXTRATAG=""
FORCETAGS="no"
KVPOSTTAG=""
ATLAS=""
QUIET=""
SNAPNAME=""
TESTTHR="1"
USEPACBALL="no"
DEBUG="no"

OPTS=`getopt -o d:D:fgH:i:k:l:m:M:oO:p:P:Qr:R:s:St:T:x:w:hcCfnNquv:V -l add-tags,check,cleanup,debug,dest:,dbrelease:,dir:,disk-free:,dump-tags:,extra-tag:,extra-pkg:,force-tags,kv-conf:,kv-disable:,kv-enable:,kvpost-tag:,grid-cache,host:,install:,kit-cache:,kv-cache:,kvpost,logical:,manage:,min-install-size:,no-opt,no-tag,override-lock,package:,pacman-ver:,pretend-platform:,physical:,project:,project-opt:,project-type:,quiet,reinstall,reinstall-clean,release-only,pacball,release-ver:,replicate,remove:,remove-snap:,remove-tags,require-shfs,require-prj:,setenv:,setup-latest:,snap:,snapname:,tags:,target:,temp-cache,test:,tthreads:,update,use-grid,vo:,validate,validation-exe:,xml:,create-dvd,write-dvd:,help,force,no-cache,no-version,query -- "$@"` 
if [ $? != 0 ] ; then echo "Terminating..."; exit -1 ; fi
eval set -- "$OPTS"

while true ; do
    case "$1" in
        --add-tags)         TAGACTION="add";shift;;
        --dump-tags)        DUMPTAGS="$2";shift 2;;
        --create-dvd|-c)    ACTION="mkiso";shift;;
        --cleanup|-C)       ACTION="cleanup";shift;;
        --check)            ACTION="check";shift;;
        --debug)            DEBUG="yes";shift;;
        --disk-free|-D)     MINDF="$2";shift 2;;
        --dbrelease)        DBREL="$2";shift 2;;
        --extra-tag)        EXTRATAG="$2";shift 2;;
        --extra-pkg)        EXTRAPKG="$2";shift 2;;
        --force-tags|-f)    FORCETAGS="yes";shift;;
        --kv-conf)          KVCONFURL="$2";shift 2;;
        --kv-disable)       KVD="$2";shift 2;;
        --kv-enable)        KVE="$2";shift 2;;
        --kvpost-tag)       KVPOSTTAG="$2";shift 2;;
        --validate|-V)      ACTION="validate";shift;;
        --force|-f)         PACMAN_OPTS="$PACMAN_OPTS -clear-lock";shift;;
        --override-lock)    PACMAN_OPTS="$PACMAN_OPTS -allow lock-override";shift;;
        --pretend-platform) PACMAN_OPTS="$PACMAN_OPTS -pretend-platform:$2";shift 2;;
        --help|-h)          help;exit;;
        --host|-H)          TAGHOST="$2";shift 2;;
        --vo)               TAGVO="$2";shift 2;;
        --install|-i)       ACTION="install";RELEASE="$2";shift 2;;
        --manage|-M)        ACTION="manage";RELEASE="$2";shift 2;;
        --kit-cache|-k)     ATLAS="$2";shift 2;;
        --min-install-size) MININSTALLSIZE="$2";shift 2;;
        --dest)             SWPATH="$2";shift 2;;
        --logical|-l)       SWLOC="$2";shift 2;;
        --no-opt)           NOOPT="yes";shift;;
        --no-tag)           NOTAG="yes";shift;;
        --no-cache|-n)      NOCACHE="yes";shift;;
        --no-version)       NOVERSION="yes";shift;;
        --package)          PACKAGE="$2";shift 2;;
        --pacman-ver|-m)    PACMAN_VER="$2";shift 2;;
        --physical|-p)      RELLOC="$2";shift 2;;
        --project|-P)       PRJNAME="$2";shift 2;;
        --project-opt|-O)   PRJOPT="$2";shift 2;;
        --project-type|-T)  PRJTYPE="`echo $2 | tr [A-Z] [a-z]`";shift 2;;
        --quiet|-Q)         QUIET="yes";shift;;
        --require-prj)      REQPRJNAME="$2";shift 2;;
        --use-grid|-g)      USEGRID="yes";shift;;
        --pacball)          USEPACBALL="yes";shift;;
        --reinstall)        REINSTALL="yes";shift;;
        --reinstall-clean)  REINSTALLCLEAN="yes";shift;;
        --release-only|-o)  PACKOPT="rel";shift;;
        --release-ver|-v)   RELVER="$2";shift 2;;
        --remove|-r)        ACTION="remove";RELEASE="$2";shift 2;;
        --remove-snap|-R)   ACTION="remove-snap";RELEASE="$2";shift 2;;
        --remove-tags)      TAGACTION="remove";shift;;
        --replicate)        GRIDREPLICA="yes";shift;;
        --require-shfs|-S)  REQSHAREDFS="yes";shift;;
        --setenv)           SETENV="$2";shift 2;;
        --setup-latest)     PRESETUP="$2";shift 2;;
        --snap|-s)          ACTION="snap";RELEASE="$2";shift 2;;
        --snapname)         SNAPNAME="$2";shift 2;;
        --tags)             TAGNAME="$2";shift 2;;
        --target|-t)        ARCH="$2";shift 2;;
        --temp-cache)       TEMPCACHE="yes";shift;;
        --test)             ACTION="test";RELEASE="$2";shift 2;;
        --tthreads)         TESTTHR="$2";shift 2;;
        --update|-u)        UPDATE="yes";shift;;
        --dir|-d)           TOPDIR="$2";shift 2;;
        --query|-q)         ACTION="query";shift;;
        --write-dvd|-w)     ACTION="writeiso";ISOIMAGE="$2";shift 2;;
        --xml|-x)           XMLFILE="${2}";shift 2;;
        --kvpost)           T_POST="yes";shift;;
        --kv-cache)         LCGCACHE="$2";shift 2;;
        --validation-exe)   VALEXE="$2";shift 2;;
        --)                 shift;break;;
        \?)                 break;
        exit;;
    esac
done

export T_POST
CATALOG_PATH="/grid/$TAGVO/install/lcg"
PRJTAGNAME="`echo $PRJNAME | sed 's#^Atlas##g' | tr [A-Z] [a-z]`"
PACMAN_OPTS="$PACMAN_OPTS -trust-all-caches -allow tar-overwrite -allow unsupported-platforms"
[ "`echo $MINDF | cut -d':' -f 1`" != "" ] && MINRELDF="`echo $MINDF | cut -d':' -f 1`"
[ "`echo $MINDF | cut -d':' -f 2`" != "" ] && MINSWDF="`echo $MINDF | cut -d':' -f 2`"
[ "`echo $MINDF | cut -d':' -f 3`" != "" ] && MINTDDF="`echo $MINDF | cut -d':' -f 3`"
[ "$TAGNAME" == "" ]  && TAGNAME="VO-atlas-${PRJTAGNAME}-${RELEASE}"
if [ "$USEGRID" == "yes" ] ; then
    CLOSESE="`edg-brokerinfo getCloseSEs 2>/dev/null| head -n 1 | awk '{ print $1}' | tr [A-Z] [a-z] | grep -v ^error`"
fi
if [ "$XMLFILE" != "" ] ; then
    [ "`dirname $XMLFILE`" == "." ] && XMLFILE="$PWD/`basename $XMLFILE`"
    xml open
fi

INSTALLER_HOME="`dirname $0`"
if [ "$XMLFILE" != "" ] ; then
    [ "$XMLFILE" == "`basename $XMLFILE`" ] && XMLFILE=$INSTALLER_HOME/$XMLFILE
fi
[ "$INSTALLER_HOME" == "." ] && INSTALLER_HOME="$PWD"
[ "$TOPDIR" == "" ] && TOPDIR="${PWD}"
[ "$ARCH"   == "" ] && ARCH="rh73"
if [ "$ACTION" == "" ] ; then
    msgOut ERROR "No action specified. Type -h for help."
    [ "$XMLFILE" != "" ] && xml close
    exit -1
fi
[ ! -d $TOPDIR ] && mkdir $TOPDIR
export PATH=$INSTALLER_HOME:$PATH
[ -s $PWD/lcg-tags ] && chmod +x $PWD/lcg-tags
[ "$LCGCACHE" == "" ] && LCGCACHE="http://classis01.roma1.infn.it/pacman/cache"
DBRELCACHE="http://atlas.web.cern.ch/Atlas/GROUPS/DATABASE/pacman4/DBRelease"
DBRELPKG="DBRelease-$DBREL"
if [ "$ATLAS" == "" ] ; then
  if [ "$PRJNAME" == "release" -o "$PRJNAME" == "AtlasRelease" ] ; then
    ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/monolith/slc3/cache"
  else
    if [ "$PRJTYPE" == "p1nightly" ] ; then
      ATLAS="$TOPDIR/AtlasPoint1.caches"
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel1/pcache/cache" > $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_0/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_1/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_2/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_3/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_4/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_5/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_6/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/kitsDirectory/projects/cache" >> $ATLAS
    elif [ "$PRJTYPE" == "bugfix" ] ; then
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/bugfix/cache"
    elif [ "$PRJTYPE" == "dev" ] ; then
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/dev/cache"
    elif [ "$PRJTYPE" == "patch" ] ; then
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/kitsDirectory/Production/cache"
      [ "$REQPRJNAME" == "" ] && REQPRJNAME="AtlasOffline"
    elif [ "$PRJTYPE" == "p1patch" ] ; then
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/kitsDirectory/Production/cache"
      [ "$REQPRJNAME" == "" ] && REQPRJNAME="AtlasOffline"
    elif [ "$PRJTYPE" == "eventview" ] ; then
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/kitsDirectory/PAT/EventView"
      [ "$REQPRJNAME" == "" ] && REQPRJNAME="AtlasOffline"
    elif [ "$PRJTYPE" == "ext" ] ; then
      ATLAS="http://classis01.roma1.infn.it/pacman/cache"
    else
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/kitsDirectory/projects/cache"
    fi
  fi
fi
PACMAN_URL="http://physics.bu.edu/pacman/sample_cache/tarballs"
PACMAN_DIR=${INSTALLER_HOME}/pacman-${PACMAN_VER}
PACMAN_TAR=${PACMAN_DIR}.tar.gz
SNAPDIR=${TOPDIR}/snapshots
# Define the snapshot name
if [ "$SNAPNAME" == "" ] ; then
  SNAPNAME="atlas-`echo ${PRJNAME} | tr [A-Z] [a-z] | sed 's#^atlas##g'``echo -${PRJTYPE} | tr [A-Z] [a-z] | sed 's#-release##g'`-${RELEASE}-${RELVER}"
  [ "$ARCH" != "" ] && SNAPNAME="${SNAPNAME}-`echo ${ARCH} | sed -e 's#^_##g'`"
  [ "$PRJOPT" != "" ] && SNAPNAME="${SNAPNAME}-${PRJOPT}"
  msgOut INFO "Self-generated snapshot name: $SNAPNAME"
else
  SNAPNAME="`echo $SNAPNAME | sed -e 's/.tar.gz//g' -e 's/.tgz//g'`"
  msgOut INFO "Requested snapshot name: $SNAPNAME"
fi

[ -s ${INSTALLER_HOME}/`basename ${SNAPDIR}`/${SNAPNAME} ] \
                      && SNAPDIR="${INSTALLER_HOME}/`basename ${SNAPDIR}`"

KV=KitValidation
if [ "$PACKAGE" != "" ] ; then
  ARC="`uname -m`"
  GCC=gcc${ARCH}
  ATLASRELEASE="${PACKAGE}"
elif [ "$ARCH" == "rh73_old" ] ; then
  GCC=gcc
  ATLASRELEASE="${RELEASE}/AtlasRelease-opt"
elif [ "$ARCH" == "slc3" ] ; then
  GCC=gcc-slc3
  ATLASRELEASE="${RELEASE}/AtlasRelease-${ARCH}-opt"
  ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/monolith/slc3/cache"
elif [ "$ARCH" == "slc3_ia32" ] ; then
  GCC=gcc-slc3
  ATLASRELEASE="${RELEASE}/AtlasRelease-${ARCH}-opt"
  ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/monolith/slc3/cache"
elif [ "`echo $ARCH | grep ^_`" != "" -a "$PRJNAME" != "release" -a "$PRJNAME" != "AtlasRelease" ] ; then
  ARC="`uname -m`"
  GCC=gcc${ARCH}
  REL="`echo ${RELEASE} | sed "s#\.#_#g"`"
  ATLASRELEASE="${PRJNAME}_${REL}${ARCH}"
  [ "$PRJOPT" != "" -a "$NOOPT" != "yes" ] && ATLASRELEASE="${ATLASRELEASE}_${PRJOPT}"
elif [ "$ARCH" == "noarch" ] ; then
  ATLASRELEASE="${PRJNAME}"
  [ "$NOVERSION" != "yes" ] && ATLASRELEASE="${ATLASRELEASE}-${RELEASE}"
else
  GCC=gcc-${ARCH}
  ATLASRELEASE="${RELEASE}/AtlasRelease-${ARCH}-opt"
fi

# Initialize the return code
let rc=0

[ "$DEBUG" == "yes" ] && msgOut DEBUG "Debug output enabled"

# Show the site info
showSiteInfo
if [ "$DEBUG" == "yes" ] ; then
    msgOut DEBUG "PATH=${PATH}"
    msgOut DEBUG "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
    msgOut DEBUG "PYTHONPATH=${PYTHONPATH}"
fi

# Setup pacman
cd "${TOPDIR}"
if [ "$ACTION" == "validate" -o "$ACTION" == "install" -o "$ACTION" == "test" -o "$ACTION" == "remove" -o "$ACTION" == "snap" ] ; then
    setupPacman
    let rc=$rc+$?
    if [ $rc -ne 0 ] ; then
        msgOut ERROR "Cannot setup pacman"
        [ "$XMLFILE" != "" ] && xml close
        exit $rc
    fi
    if [ "$DEBUG" == "yes" ] ; then
        msgOut DEBUG "PATH=${PATH}"
        msgOut DEBUG "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
        msgOut DEBUG "PYTHONPATH=${PYTHONPATH}"
    fi
fi

# Define the installation directories
if [ "$SWLOC" == ""  ] ; then
    [ "$RELLOC" != "" ] && SWLOC="$RELLOC" \
                        || SWLOC="${TOPDIR}/software/${RELEASE}"
fi
[ "$RELLOC" == "" ] && RELLOC=${TOPDIR}/releases
[ ! -d "$RELLOC" -a -d ${TOPDIR}/releases/`basename $RELLOC` ] && RELLOC=${TOPDIR}/releases/`basename $RELLOC`
if [ "$ACTION" == "install" -o "$ACTION" == "validate" ] ; then
    prepareInstallDirs
    let rc=$rc+$?
    if [ $rc -ne 0 ] ; then
        msgOut ERROR "Cannot create the installation directories. The installer will now exit."
        [ "$XMLFILE" != "" ] && xml close
        exit $rc
    fi
fi

# Save the environment
export ENVSTART="/tmp/sw-mgr-envstart.tmp.$$"
msgOut INFO "Saving the installation environment in $ENVSTART"
#/usr/bin/printenv | grep -v '^_=' | sed -e "s/\([^=]\)=/\1='/" -e "s/$/'/g" > $ENVSTART
/usr/bin/env | cut -d'=' -f 1 | egrep -v '^_$|^\s|^	|^$' | while read var; do echo "$var='`/usr/bin/printenv $var`'"; done > $ENVSTART
[ "$LD_LIBRARY_PATH" == "" ] && echo "unset LD_LIBRARY_PATH" >> $ENVSTART
[ "$PYTHONPATH" == "" ] && echo "unset PYTHONPATH" >> $ENVSTART

# Perform the pre-setup, if required
if [ "$PRESETUP" != "" ] ; then
    LATESTREL="`find $PRESETUP -maxdepth 5 -name "AtlasOffline" 2>/dev/null | while read d; do \ls -d $d/*; done | sort | tail -n 1`"
    LATESTSETUP="`echo $LATESTREL | awk -F "/" '{for(i=1;i<NF-1;i++) printf $i"/";}'`cmtsite/setup.sh"
    if [ -s "$LATESTSETUP" ] ; then
        msgOut INFO "Setting up the latest release from $LATESTSETUP"
        msgOut INFO "source ${LATESTSETUP} -tag=AtlasOffline,`basename $LATESTREL`,runtime"
        source ${LATESTSETUP} -tag=AtlasOffline,`basename $LATESTREL`,runtime
    else
        msgOut WARNING "Cannot setup a suitable release from $PRESETUP"
    fi
fi

# Execute the actions
if [ "$ACTION" == "install" -o "$ACTION" == "validate" ] ; then
    if [ "$REINSTALL" == "yes" ] ; then
        RELLOCBASE="$RELLOC"
        RELLOCINDX="`\ls -d ${RELLOC}.r* 2> /dev/null | wc -l`"
        let RELLOCINDX=$RELLOCINDX+1
        RELLOC="${RELLOC}.r${RELLOCINDX}"
        msgOut INFO "Re-installation requested. Installing in $RELLOC."
        if [ "$REINSTALLCLEAN" == "yes" ] ; then
            msgOut INFO "Re-installation cleanup requested. Removing the old stuff."
            remove
        fi
        prepareInstallDirs
        let rc=$rc+$?
        if [ $rc -ne 0 ] ; then
            msgOut ERROR "Cannot create the installation directories. The installer will now exit."
            [ "$XMLFILE" != "" ] && xml close
            exit $rc
        fi
    else
        msgOut INFO "Starting the normal installation phase."
    fi

    # Check the site parameters for the installation
    checkSite
    let rc=$rc+$?

    # Install only if everything is OK
    if [ $rc -eq 0 ] ; then
        install
        let rc=$rc+$?
        if [ "$ACTION" == "validate" ] ; then
            if [ $rc -eq 0 ] ; then
                validate
                let rc=$rc+$?
            else
                msgOut INFO "Skipping validation due to previous errors"
            fi
        fi
        if [ $rc -eq 0 -o "$FORCETAGS" == "yes" ] ; then
            if [ "$TAGACTION" == "add" ] ; then
                addTag
                let tagrc=$?
                [ $tagrc -ne 0 ] && msgOut ERROR "Cannot add tags"
                let rc=$rc+$tagrc
            fi
        fi
    fi
elif [ "$ACTION" == "test" ] ; then
    validate
    let rc=$rc+$?
    if [ "$NOTAG" != "yes" ] ; then
        if [ $rc -eq 0 ] ; then
            addTag
        else
            removeTag
        fi
        let tagrc=$?
        [ $tagrc -ne 0 ] && msgOut ERROR "Cannot manage tags"
        let rc=$rc+$tagrc
    fi
elif [ "$ACTION" == "remove" ] ; then
    if [ "$TAGACTION" == "remove" ] ; then
        removeTag
        let tagrc=$?
        [ $tagrc -ne 0 ] && msgOut ERROR "Cannot remove tags"
        let rc=$rc+$tagrc
    fi
    if [ $rc -eq 0 ] ; then
        remove
        let rc=$rc+$?
    else
        msgOut ERROR "Skipping software removal due to previous problems."
    fi
elif [ "$ACTION" == "manage" ] ; then
    if [ "$TAGACTION" == "add" ] ; then
        addTag
    elif [ "$TAGACTION" == "remove" ] ; then
        removeTag
    fi
    let tagrc=$?
    [ $tagrc -ne 0 ] && msgOut ERROR "Cannot manage tags"
    let rc=$rc+$tagrc
elif [ "$ACTION" == "check" ] ; then
    checkSite
    let rc=$rc+$?
elif [ "$ACTION" == "remove-snap" ] ; then
    rm -f $SNAPDIR/${SNAPNAME}
    let rc=$rc+$?
elif [ "$ACTION" == "snap" ] ; then
    if [ "$USEPACBALL" != "yes" ] ; then
        snap "$SNAPDIR" "${SNAPNAME}"
    else
        pacball "$SNAPDIR" "${SNAPNAME}"
    fi
    let rc=$rc+$?
elif [ "$ACTION" == "query" ] ; then
    query
    let rc=$rc+$?
elif [ "$ACTION" == "cleanup" ] ; then
    cleanup
    let rc=$rc+$?
    if [ $rc -eq 0 ] ; then
        if [ "$TAGACTION" == "add" ] ; then
            addTag
        elif [ "$TAGACTION" == "remove" ] ; then
            removeTag
        fi
        let tagrc=$?
        [ $tagrc -ne 0 ] && msgOut ERROR "Cannot manage tags"
        let rc=$rc+$tagrc
    fi
elif [ "$ACTION" == "mkiso" ] ; then
    mkiso "atlas-kit-DVD-`date +%Y%m%d`.iso" "Atlas_`query -quiet`" "${USER}" "${TOPDIR}/sw-mgr ${PACMAN_DIR} ${TOPDIR}/patches ${SNAPDIR}"
    let rc=$rc+$?
elif [ "$ACTION" == "writeiso" ] ; then
    writeDVD "${ISOIMAGE}"
    let rc=$rc+$?
fi

# Autoclean $TOPDIR if it is in /tmp or in $VO_ATLAS_SW_DIR
#if [ -d $TOPDIR -a "`dirname $TOPDIR`" == "/tmp" ] ; then
#    msgOut INFO  "Removing $TOPDIR"
#    rm -fr $TOPDIR
#fi
#if [ -d $TOPDIR -a "`dirname $TOPDIR`" == "$VO_ATLAS_SW_DIR" -a "$VO_ATLAS_SW_DIR" != "" ] ; then
#    msgOut INFO  "Removing $TOPDIR"
#    rm -fr $TOPDIR
#fi

# Clean up other files
if [ -f $ENVSTART ] ; then
    msgOut INFO  "Removing temporary environment file $ENVSTART"
    rm -fr $ENVSTART
fi

# Exit the installer
if [ $rc -eq 0 ] ; then
    msgOut INFO  "Processing OK"
else
    msgOut ERROR "Processing FAILED"
fi

# Close the xml file
[ "$XMLFILE" != "" ] && xml close

# Exit with the appropriate return code
exit $rc
